package app;

import components.TerranPlanar;
import libnoiseforjava.persistence.Output;
import libnoiseforjava.util.ImageCafe;

import static org.junit.Assert.assertTrue;

import java.util.ArrayList;
import java.util.List;

import libnoiseforjava.NoiseGen.NoiseQuality;
import libnoiseforjava.domain.Builder;
import libnoiseforjava.domain.GradientPointParameter;
import libnoiseforjava.domain.RenderImageParameter;
import libnoiseforjava.domain.RenderImageSphereParameter;
import libnoiseforjava.module.Add;
import libnoiseforjava.module.Billow;
import libnoiseforjava.module.Blend;
import libnoiseforjava.module.Cached;
import libnoiseforjava.module.Clamp;
import libnoiseforjava.module.Const;
import libnoiseforjava.module.Curve;
import libnoiseforjava.module.Exponent;
import libnoiseforjava.module.Max;
import libnoiseforjava.module.Min;
import libnoiseforjava.module.Multiply;
import libnoiseforjava.module.Perlin;
import libnoiseforjava.module.RidgedMulti;
import libnoiseforjava.module.ScaleBias;
import libnoiseforjava.module.Select;
import libnoiseforjava.module.Terrace;
import libnoiseforjava.module.Turbulence;
import libnoiseforjava.module.Voronoi;
import libnoiseforjava.persistence.Output;
import libnoiseforjava.util.ColorCafe;
import libnoiseforjava.util.ImageCafe;
import libnoiseforjava.util.NoiseMap;
import libnoiseforjava.util.NoiseMapBuilder;
import libnoiseforjava.util.NoiseMapBuilderSphere;
import libnoiseforjava.util.RendererImage;

import com.zenred.util.GenRandomRolls;

public class TerranPlanarStaticAppRand {

	/**
	 * these values should either be generated by an AI engine and (possibly
	 * persisted in the store)
	 */

	// //////////////////////////////////////////////////////////////////////////
	// Constants
	//
	// Modify these constants to change the terrain of the planet and to change
	// the boundaries and size of the elevation grid.
	//
	// Note: "Planetary elevation units" range from -1.0 (for the lowest
	// underwater trenches) to +1.0 (for the highest mountain peaks.)
	//

	// Planet seed. Change this to generate a different planet
	// A different planet each test (almost always)
	private static Integer CUR_SEED = GenRandomRolls.Instance().getD250000();
	// Frequency of the planet's continents. Higher frequency produces smaller,
	// more numerous continents. This value is measured in radians.
	private static Double CONTINENT_FREQUENCY = 1.2-GenRandomRolls.Instance().draw_rand();
	// The persistence value controls the roughness of the Perlin noise,
	// normally between 0.0 and 1.0
	private static Double BASE_CONTINENT_DEF_PERSISTENCE_0 = 0.5;
	private static Double BASE_CONTINENT_DEF_PERSISTENCE_1 = 0.5;
	// Lacunarity. from Latin meaning gap, or fill space
	// Lacunarity of the planet's continents. Changing this value produces
	// slightly different continents. For the best results, this value should
	// be random, but close to 2.0.
	private static Double CONTINENT_LACUNARITY = 2.208984375;
	// Octave count determines the amount of Perlin noise, the higher the count,
	// the more detail
	private static Integer BASE_CONTINENT_DEF_OCTAVE_COUNT_PE0 = 14;
	private static Integer BASE_CONTINENT_DEF_OCTAVE_COUNT_PE1 = 11;
	// Specifies the planet's sea level. This value must be between -1.0
	// (minimum planet elevation) and +1.0 (maximum planet elevation.)
	private static Double SEA_LEVEL = 0.0;
	// / Sets the bias to apply to the scaled output value from the source
	// / module.
	private static Double DEEP_SEA_LEVEL = -256.0;
	private static Double BASE_CONTINENT_DEF_BIAS = 0.625;
	// / Sets the scaling factor to apply to the output value from the
	// / source module.
	private static Double BASE_CONTINENT_DEF_SCALE = 0.375;
	// noise clamping bounds
	private static Double BASE_CONTINENT_DEF_CLAMP_LOWER_BOUND = -1.0;
	private static Double BASE_CONTINENT_DEF_CLAMP_UPPER_BOUND = 1.0;
	// Minimum elevation on the planet, in meters. This value is approximate.
	private static Double MIN_ELEV = -8192.0;
	// Maximum elevation on the planet, in meters. This value is approximate.
	private static Double MAX_ELEV = 8192.0;
	// sea level calculation parameters
	private static Double PARAMETER0 = 1.0;
	private static Double PARAMETER1 = 2.0;
	// Calculate the sea level, in meters
	private static Double seaLevelInMeters = (((SEA_LEVEL + PARAMETER0) / PARAMETER1) * (MAX_ELEV - MIN_ELEV))
			+ MIN_ELEV;
	// Southernmost coordinate of elevation grid.
	private static Double SOUTH_COORD = -90.0;
	// Northernmost coordinate of elevation grid.
	private static Double NORTH_COORD = 90.0;
	// Westernmost coordinate of elevation grid.
	private static Double WEST_COORD = -180.0;
	// Easternmost coordinate of elevation grid.
	private static Double EAST_COORD = 180.0;
	// Width of elevation grid, in points
	private static Integer GRID_WIDTH = 2048;
	// Height of elevation grid, in points
	private static Integer GRID_HEIGHT = 1024;

	private static Double PLANET_CIRCUMFERENCE = 44236800.0;
	private static Double METERS_PER_DEGREE = PLANET_CIRCUMFERENCE / GenRandomRolls.Instance().getD360();

	// Offset to apply to the terrain type definition. Low values (< 1.0) cause
	// the rough areas to appear only at high elevations. High values (> 2.0)
	// cause the rough areas to appear at any elevation. The percentage of
	// rough areas on the planet are independent of this value.
	private static Double TERRAIN_OFFSET = 1.0;

	//

	// create a spherical-noise-map builder
	private static NoiseMapBuilderSphere planet = new NoiseMapBuilderSphere();
	private static NoiseMap elevGrid = new NoiseMap(GRID_WIDTH, GRID_HEIGHT);
	static {
		planet.setBounds(SOUTH_COORD, NORTH_COORD, WEST_COORD, EAST_COORD);
		planet.setDestSize(GRID_WIDTH, GRID_HEIGHT);

	}

	// surface map
	static List<GradientPointParameter> gradientPointList = new ArrayList<GradientPointParameter>();
	static {
		GradientPointParameter gradientPointParameter = new GradientPointParameter(-16384.0 + seaLevelInMeters,
				new ColorCafe(3, 29, 63, 255));
		gradientPointList.add(gradientPointParameter);
		gradientPointParameter = new GradientPointParameter(DEEP_SEA_LEVEL + seaLevelInMeters,
				new ColorCafe(3, 29, 63, 255));
		gradientPointList.add(gradientPointParameter);
		gradientPointParameter = new GradientPointParameter(-1.0 + seaLevelInMeters, new ColorCafe(7, 106, 127, 255));
		gradientPointList.add(gradientPointParameter);
		gradientPointParameter = new GradientPointParameter(0.0 + seaLevelInMeters, new ColorCafe(62, 86, 30, 255));
		gradientPointList.add(gradientPointParameter);
		gradientPointParameter = new GradientPointParameter(1024.0 + seaLevelInMeters, new ColorCafe(84, 96, 50, 255));
		gradientPointList.add(gradientPointParameter);
		gradientPointParameter = new GradientPointParameter(2048.0 + seaLevelInMeters,
				new ColorCafe(130, 127, 97, 255));
		gradientPointList.add(gradientPointParameter);
		gradientPointParameter = new GradientPointParameter(3072.0 + seaLevelInMeters,
				new ColorCafe(184, 163, 141, 255));
		gradientPointList.add(gradientPointParameter);
		gradientPointParameter = new GradientPointParameter(4096.0 + seaLevelInMeters,
				new ColorCafe(255, 255, 255, 255));
		gradientPointList.add(gradientPointParameter);
		gradientPointParameter = new GradientPointParameter(6144.0 + seaLevelInMeters,
				new ColorCafe(128, 255, 255, 255));
		gradientPointList.add(gradientPointParameter);
		gradientPointParameter = new GradientPointParameter(16384.0 + seaLevelInMeters, new ColorCafe(0, 0, 255, 255));
		gradientPointList.add(gradientPointParameter);

	}

	// image colored by elevation and artificial light source
	static List<GradientPointParameter> gradientPointList2 = new ArrayList<GradientPointParameter>();
	static {
		GradientPointParameter gradientPointParameter = new GradientPointParameter(-16384.0 + seaLevelInMeters,
				new ColorCafe(0, 0, 0, 255));
		gradientPointParameter = new GradientPointParameter(-256.0 + seaLevelInMeters, new ColorCafe(6, 58, 127, 255));
		gradientPointList2.add(gradientPointParameter);
		gradientPointParameter = new GradientPointParameter(-1.0 + seaLevelInMeters, new ColorCafe(14, 112, 192, 255));
		gradientPointList2.add(gradientPointParameter);
		gradientPointParameter = new GradientPointParameter(0.0 + seaLevelInMeters, new ColorCafe(70, 120, 60, 255));
		gradientPointList2.add(gradientPointParameter);
		gradientPointParameter = new GradientPointParameter(1024.0 + seaLevelInMeters,
				new ColorCafe(110, 140, 75, 255));
		gradientPointList2.add(gradientPointParameter);
		gradientPointParameter = new GradientPointParameter(2048.0 + seaLevelInMeters,
				new ColorCafe(160, 140, 111, 255));
		gradientPointList2.add(gradientPointParameter);
		gradientPointParameter = new GradientPointParameter(3072.0 + seaLevelInMeters,
				new ColorCafe(184, 163, 141, 255));
		gradientPointList2.add(gradientPointParameter);
		gradientPointParameter = new GradientPointParameter(4096.0 + seaLevelInMeters,
				new ColorCafe(255, 255, 255, 255));
		gradientPointList2.add(gradientPointParameter);
		gradientPointParameter = new GradientPointParameter(6144.0 + seaLevelInMeters,
				new ColorCafe(128, 255, 255, 255));
		gradientPointList2.add(gradientPointParameter);
		gradientPointParameter = new GradientPointParameter(16384.0 + seaLevelInMeters, new ColorCafe(0, 0, 255, 255));
	}

	static Double lightBrightness = new Double(2.0);
	static Double lightElevation = new Double(45.0);
	static Double lightAzumith = new Double(135.0);

	static Double degExtent = EAST_COORD - WEST_COORD;
	static Double gridExtent = new Double(GRID_WIDTH);
	// double resInMeters = (degExtent / gridExtent) * metersPerDegree;
	static Double resInMeters = (degExtent / gridExtent) * METERS_PER_DEGREE;
	static Double INVERSE_RES_IN_METERS = 1.0 / resInMeters;

	static Double lightContrast = new Double(1.0 / resInMeters);

	// Specifies the level on the planet in which continental shelves appear.
	// This value must be between -1.0 (minimum planet elevation) and +1.0
	// (maximum planet elevation), and must be less than SEA_LEVEL.
	static Double SHELF_LEVEL = -0.375;

	// Lacunarity of the planet's mountains. Changing this value produces
	// slightly different mountains. For the best results, this value should
	// be random, but close to 2.0.
	static Double MOUNTAIN_LACUNARITY = 2.142578125;

	// Specifies the "twistiness" of the mountains.
	static Double MOUNTAINS_TWIST = 1.0;
	// Specifies the amount of "glaciation" on the mountains. This value
	// should be close to 1.0 and greater than 1.0.
	static Double MOUNTAIN_GLACIATION = 1.375;
	// Lacunarity of the planet's hills. Changing this value produces slightly
	// different hills. For the best results, this value should be random, but
	// close to 2.0.
	static Double HILLS_LACUNARITY = 2.162109375;
	// Specifies the "twistiness" of the hills
	static Double HILLS_TWIST = 1.0;
	// Lacunarity of the planet's plains. Changing this value produces slightly
	// different plains. For the best results, this value should be random, but
	// close to 2.0.
	static Double PLAINS_LACUNARITY = 2.314453125;
	// Lacunarity of the planet's badlands. Changing this value produces
	// slightly different badlands. For the best results, this value should be
	// random, but close to 2.0.
	static Double BADLANDS_LACUNARITY = 2.212890625;
	// Specifies the "twistiness" of the badlands.
	static Double BADLANDS_TWIST = 1.0;
	// Scaling to apply to the base continent elevations, in planetary elevation
	// units.
	static Double CONTINENT_HEIGHT_SCALE = (1.0 - SEA_LEVEL) / 4.0;
	// Determines the amount of mountainous terrain that appears on the
	// planet. Values range from 0.0 (no mountains) to 1.0 (all terrain is
	// covered in mountains). Mountainous terrain will overlap hilly terrain.
	// Because the badlands terrain may overlap parts of the mountainous
	// terrain, setting MOUNTAINS_AMOUNT to 1.0 may not completely cover the
	// terrain in mountains.
	static Double MOUNTAINS_AMOUNT = 0.5;
	// Determines the amount of hilly terrain that appears on the planet.
	// Values range from 0.0 (no hills) to 1.0 (all terrain is covered in
	// hills). This value must be less than MOUNTAINS_AMOUNT. Because the
	// mountainous terrain will overlap parts of the hilly terrain, and
	// the badlands terrain may overlap parts of the hilly terrain, setting
	// HILLS_AMOUNT to 1.0 may not completely cover the terrain in hills.
	static Double HILLS_AMOUNT = (1.0 + MOUNTAINS_AMOUNT) / 2.0;
	// Determines the amount of badlands terrain that covers the planet.
	// Values range from 0.0 (no badlands) to 1.0 (all terrain is covered in
	// badlands.) Badlands terrain will overlap any other type of terrain.
	static Double BADLANDS_AMOUNT = 0.03125;
	// Maximum depth of the rivers, in planetary elevation units.
	static Double RIVER_DEPTH = 0.0234375;

	// 1: [Continent module]: This Perlin-noise module generates the continents.
	// This noise module has a high number of octaves so that detail is
	// visible at high zoom levels.

	static private Perlin baseContinentDef_pe0 = new Perlin();
	static {
		baseContinentDef_pe0.setSeed(CUR_SEED);
		baseContinentDef_pe0.setFrequency(CONTINENT_FREQUENCY);
		baseContinentDef_pe0.setPersistence(BASE_CONTINENT_DEF_PERSISTENCE_0);
		baseContinentDef_pe0.setLacunarity(CONTINENT_LACUNARITY);
		baseContinentDef_pe0.setOctaveCount(BASE_CONTINENT_DEF_OCTAVE_COUNT_PE0);
		baseContinentDef_pe0.setNoiseQuality(NoiseQuality.QUALITY_STD);
	}

	// 2: [Continent-with-ranges module]: Next, a curve module modifies the
	// output value from the continent module so that very high values appear
	// near sea level. This defines the positions of the mountain ranges.
	static private Curve baseContinentDef_cu = new Curve(baseContinentDef_pe0);
	static {
		baseContinentDef_cu.addControlPoint(-2.0000 + SEA_LEVEL, -1.625 + SEA_LEVEL);
		baseContinentDef_cu.addControlPoint(-1.0000 + SEA_LEVEL, -1.375 + SEA_LEVEL);
		baseContinentDef_cu.addControlPoint(0.0000 + SEA_LEVEL, -0.375 + SEA_LEVEL);
		baseContinentDef_cu.addControlPoint(0.0625 + SEA_LEVEL, 0.125 + SEA_LEVEL);
		baseContinentDef_cu.addControlPoint(0.1250 + SEA_LEVEL, 0.250 + SEA_LEVEL);
		baseContinentDef_cu.addControlPoint(0.2500 + SEA_LEVEL, 1.000 + SEA_LEVEL);
		baseContinentDef_cu.addControlPoint(0.5000 + SEA_LEVEL, 0.250 + SEA_LEVEL);
		baseContinentDef_cu.addControlPoint(0.7500 + SEA_LEVEL, 0.250 + SEA_LEVEL);
		baseContinentDef_cu.addControlPoint(1.0000 + SEA_LEVEL, 0.500 + SEA_LEVEL);
		baseContinentDef_cu.addControlPoint(2.0000 + SEA_LEVEL, 0.500 + SEA_LEVEL);

	}
	// 3: [Carver module]: This higher-frequency Perlin-noise module will be
	// used by subsequent noise modules to carve out chunks from the mountain
	// ranges within the continent-with-ranges module so that the mountain
	// ranges will not be complely impassible.

	static private Perlin baseContinentDef_pe1 = new Perlin();
	static {
		baseContinentDef_pe1.setSeed(CUR_SEED + 1);
		baseContinentDef_pe1.setFrequency(CONTINENT_FREQUENCY);
		baseContinentDef_pe1.setPersistence(BASE_CONTINENT_DEF_PERSISTENCE_1);
		baseContinentDef_pe1.setLacunarity(CONTINENT_LACUNARITY);
		baseContinentDef_pe1.setOctaveCount(BASE_CONTINENT_DEF_OCTAVE_COUNT_PE1);
		baseContinentDef_pe1.setNoiseQuality(NoiseQuality.QUALITY_STD);
	}

	// 4: [Scaled-carver module]: This scale/bias module scales the output
	// value from the carver module such that it is usually near 1.0. This
	// is required for step 5.

	static private ScaleBias baseContinentDef_sb = new ScaleBias(baseContinentDef_pe1);
	static {
		baseContinentDef_sb.setScale(BASE_CONTINENT_DEF_SCALE);
		baseContinentDef_sb.setBias(BASE_CONTINENT_DEF_BIAS);
	}

	// 5: [Carved-continent module]: This minimum-value module carves out chunks
	// from the continent-with-ranges module. It does this by ensuring that
	// only the minimum of the output values from the scaled-carver module
	// and the continent-with-ranges module contributes to the output value
	// of this subgroup. Most of the time, the minimum-value module will
	// select the output value from the continents-with-ranges module since
	// the output value from the scaled-carver module is usually near 1.0.
	// Occasionally, the output value from the scaled-carver module will be
	// less than the output value from the continent-with-ranges module, so
	// in this case, the output value from the scaled-carver module is
	// selected.
	static private Min baseContinentDef_mi = new Min(baseContinentDef_sb, baseContinentDef_cu);

	// 6: [Clamped-continent module]: Finally, a clamp module modifies the
	// carved-continent module to ensure that the output value of this
	// subgroup is between -1.0 and 1.0.

	static private Clamp baseContinentDef_cl = new Clamp(baseContinentDef_mi);
	static {
		baseContinentDef_cl.setBounds(BASE_CONTINENT_DEF_CLAMP_LOWER_BOUND, BASE_CONTINENT_DEF_CLAMP_UPPER_BOUND);
	}

	static private Cached baseContinentDef = new Cached(baseContinentDef_cl);

	// //////////////////////////////////////////////////////////////////////////
	// Module subgroup: continent definition (5 noise modules)
	//
	// This subgroup warps the output value from the the base-continent-
	// definition subgroup, producing more realistic terrain.
	//
	// Warping the base continent definition produces lumpier terrain with
	// cliffs and rifts.
	//
	// -1.0 represents the lowest elevations and +1.0 represents the highest
	// elevations.
	//

	// 1: [Coarse-turbulence module]: This turbulence module warps the output
	// value from the base-continent-definition subgroup, adding some coarse
	// detail to it.
	static private Double TU0_FREQUENCY = 15.25;
	// / The frequency of the turbulence determines how rapidly the
	// / displacement amount changes.
	static private Double TU0_POWER_SCALAR = 113.75;
	// / The power of the turbulence determines the scaling factor that is
	// / applied to the displacement amount.
	static private Integer TU0_ROUGHNESS = 13;
	// / The roughness of the turbulence determines the roughness of the
	// / changes to the displacement amount. Low values smoothly change
	// / the displacement amount. High values roughly change the
	// / displacement amount, which produces more "kinky" changes.
	// /
	// / Internally, there are three Perlin noise modules
	// / that displace the input value; one for the @a x, one for the @a y,
	// / and one for the @a z coordinate. The roughness value is equal to
	// / the number of octaves used by the noise::module::Perlin noise
	// / modules.

	static private Turbulence continentDef_tu0 = new Turbulence(baseContinentDef);
	static {
		continentDef_tu0.setSeed(CUR_SEED + 10);
		continentDef_tu0.setFrequency(TU0_FREQUENCY * CONTINENT_FREQUENCY);
		continentDef_tu0.setPower(CONTINENT_FREQUENCY / TU0_POWER_SCALAR);
		continentDef_tu0.setRoughness(TU0_ROUGHNESS);
	}

	// 2: [Intermediate-turbulence module]: This turbulence module warps the
	// output value from the coarse-turbulence module. This turbulence has
	// a higher frequency, but lower power, than the coarse-turbulence
	// module, adding some intermediate detail to it.

	static private Double TU1_FREQUENCY = 47.25;
	static private Double TU1_POWER_SCALAR = 433.75;
	static private Integer TU1_ROUGHNESS = 12;

	static private Turbulence continentDef_tu1 = new Turbulence(continentDef_tu0);
	static {
		continentDef_tu1.setSeed(CUR_SEED + 11);
		continentDef_tu1.setFrequency(TU1_FREQUENCY * CONTINENT_FREQUENCY);
		continentDef_tu1.setPower(CONTINENT_FREQUENCY / TU1_POWER_SCALAR);
		continentDef_tu1.setRoughness(TU1_ROUGHNESS);
	}

	// 3: [Warped-base-continent-definition module]: This turbulence module
	// warps the output value from the intermediate-turbulence module. This
	// turbulence has a higher frequency, but lower power, than the
	// intermediate-turbulence module, adding some fine detail to it.

	static private Double TU2_FREQUENCY = 95.25;
	static private Double TU2_POWER_SCALAR = 1019.75;
	static private Integer TU2_ROUGHNESS = 11;

	static private Turbulence continentDef_tu2 = new Turbulence(continentDef_tu1);
	static {
		continentDef_tu2.setSeed(CUR_SEED + 12);
		continentDef_tu2.setFrequency(TU2_FREQUENCY * CONTINENT_FREQUENCY);
		continentDef_tu2.setPower(CONTINENT_FREQUENCY / TU2_POWER_SCALAR);
		continentDef_tu2.setRoughness(TU2_ROUGHNESS);

	}
	// 4: [Select-turbulence module]: At this stage, the turbulence is applied
	// to the entire base-continent-definition subgroup, producing some very
	// rugged, unrealistic coastlines. This selector module selects the
	// output values from the (unwarped) base-continent-definition subgroup
	// and the warped-base-continent-definition module, based on the output
	// value from the (unwarped) base-continent-definition subgroup. The
	// selection boundary is near sea level and has a relatively smooth
	// transition. In effect, only the higher areas of the base-continent-
	// definition subgroup become warped; the underwater and coastal areas
	// remain unaffected.

	// / The control module (baseContinentDef) determines the output value to
	// select. If the
	// / output value from the control module is within a range of values
	// / known as the <i>selection range</i>, the getValue() method outputs
	// / the value from the source module with an index value of 1.
	// / Otherwise, this method outputs the value from the source module
	// / with an index value of 0.
	// /
	// / This method assigns the control module an index value of 2.
	// / Passing the control module to this method produces the same
	// / results as passing the control module to the setSourceModule()
	// / method while assigning that noise module an index value of 2.
	// /
	// / This control module must exist throughout the lifetime of this
	// / noise module unless another control module replaces that control
	// / module.

	private static Double CONTINENT_DEF_SE_LOWER_BOUNDS = SEA_LEVEL - 0.0375;
	private static Double CONTINENT_DEF_SE_UPPER_BOUNDS = SEA_LEVEL + 1000.0375;
	private static Double CONTINENT_DEF_SE_EDGE_FALLOFF = 0.0625;
	// / By default, there is an abrupt transition between the values from
	// / the two source modules at the boundaries of the selection range.
	// /
	// / For example, if the selection range is 0.5 to 0.8, and the edge
	// / falloff value is 0.1, then the getValue() method outputs:
	// / - the output value from the source module with an index value of 0
	// / if the output value from the control module is less than 0.4
	// / ( = 0.5 - 0.1).
	// / - a linear blend between the two output values from the two source
	// / modules if the output value from the control module is between
	// / 0.4 ( = 0.5 - 0.1) and 0.6 ( = 0.5 + 0.1).
	// / - the output value from the source module with an index value of 1
	// / if the output value from the control module is between 0.6
	// / ( = 0.5 + 0.1) and 0.7 ( = 0.8 - 0.1).
	// / - a linear blend between the output values from the two source
	// / modules if the output value from the control module is between
	// / 0.7 ( = 0.8 - 0.1 ) and 0.9 ( = 0.8 + 0.1).
	// / - the output value from the source module with an index value of 0
	// / if the output value from the control module is greater than 0.9
	// / ( = 0.8 + 0.1).

	static private Select continentDef_se = new Select(baseContinentDef, continentDef_tu2, baseContinentDef);
	static {
		continentDef_se.setBounds(CONTINENT_DEF_SE_LOWER_BOUNDS, CONTINENT_DEF_SE_UPPER_BOUNDS);
		continentDef_se.setEdgeFalloff(CONTINENT_DEF_SE_EDGE_FALLOFF);
	}

	static private Cached continentDef = new Cached(continentDef_se);

	// //////////////////////////////////////////////////////////////////////////
	// Module group: terrain type definition
	// //////////////////////////////////////////////////////////////////////////

	// //////////////////////////////////////////////////////////////////////////
	// Module subgroup: terrain type definition (3 noise modules)
	//
	// This subgroup defines the positions of the terrain types on the planet.
	//
	// Terrain types include, in order of increasing roughness, plains, hills,
	// and mountains.
	//
	// This subgroup's output value is based on the output value from the
	// continent-definition group. Rougher terrain mainly appears at higher
	// elevations.
	//
	// -1.0 represents the smoothest terrain types (plains and underwater) and
	// +1.0 represents the roughest terrain types (mountains).
	//

	// 1: [Warped-continent module]: This turbulence module slightly warps the
	// output value from the continent-definition group. This prevents the
	// rougher terrain from appearing exclusively at higher elevations.
	// Rough areas may now appear in the the ocean, creating rocky islands
	// and fjords.

	static private Double TERRAIN_TYPE_TU_FREQUENCY = 18.125;
	static private Double TERRAIN_TYPE_TU_POWER = 20.59375;
	static private Integer TERRAIN_TYPE_TU_ROUGHNESS = 3;
	static private Turbulence terrainTypeDef_tu = new Turbulence(continentDef);
	static {
		terrainTypeDef_tu.setSeed(CUR_SEED + 20);
		terrainTypeDef_tu.setFrequency(CONTINENT_FREQUENCY * TERRAIN_TYPE_TU_FREQUENCY);
		terrainTypeDef_tu.setPower(CONTINENT_FREQUENCY / TERRAIN_TYPE_TU_POWER * TERRAIN_OFFSET);
		terrainTypeDef_tu.setRoughness(TERRAIN_TYPE_TU_ROUGHNESS);
	}

	// 2: [Roughness-probability-shift module]: This terracing module sharpens
	// the edges of the warped-continent module near sea level and lowers
	// the slope towards the higher-elevation areas. This shrinks the areas
	// in which the rough terrain appears, increasing the "rarity" of rough
	// terrain.
	static private Double TERRAIN_TYPE_DEF_LOW_CONTROL_POINT = -1.00;
	static private Double TERRAIN_TYPE_DEF_MID_CONTROL_POINT_SCALAR = 2.00;
	static private Double TERRAIN_TYPE_DEF_HIGH_CONTROL_POINT = 1.00;

	static private Terrace terrainTypeDef_te = new Terrace(terrainTypeDef_tu);
	static {
		terrainTypeDef_te.addControlPoint(TERRAIN_TYPE_DEF_LOW_CONTROL_POINT);
		terrainTypeDef_te.addControlPoint(SHELF_LEVEL + SEA_LEVEL / TERRAIN_TYPE_DEF_MID_CONTROL_POINT_SCALAR);
		terrainTypeDef_te.addControlPoint(TERRAIN_TYPE_DEF_HIGH_CONTROL_POINT);

	}

	static private Cached terrainTypeDef = new Cached(terrainTypeDef_te);

	// //////////////////////////////////////////////////////////////////////////
	// Module group: mountainous terrain
	// //////////////////////////////////////////////////////////////////////////

	// //////////////////////////////////////////////////////////////////////////
	// Module subgroup: mountain base definition (9 noise modules)
	//
	// This subgroup generates the base-mountain elevations. Other subgroups
	// will add the ridges and low areas to the base elevations.
	//
	// -1.0 represents low mountainous terrain and +1.0 represents high
	// mountainous terrain.
	//

	// 1: [Mountain-ridge module]: This ridged-multifractal-noise module
	// generates the mountain ridges.
	static private Double MOUNTAIN_BASE_DEF_RM0_FREQUENCY = 1723.0;
	static private Integer MOUNTAIN_BASE_DEF_RM0_OCTAVE_COUNT = 4;
	static private RidgedMulti mountainBaseDef_rm0 = new RidgedMulti();
	static {
		mountainBaseDef_rm0.setSeed(CUR_SEED + 30);
		mountainBaseDef_rm0.setFrequency(MOUNTAIN_BASE_DEF_RM0_FREQUENCY);
		mountainBaseDef_rm0.setLacunarity(MOUNTAIN_LACUNARITY);
		mountainBaseDef_rm0.setOctaveCount(MOUNTAIN_BASE_DEF_RM0_OCTAVE_COUNT);
		mountainBaseDef_rm0.setNoiseQuality(NoiseQuality.QUALITY_STD);
	}

	// 2: [Scaled-mountain-ridge module]: Next, a scale/bias module scales the
	// output value from the mountain-ridge module so that its ridges are not
	// too high. The reason for this is that another subgroup adds actual
	// mountainous terrain to these ridges.
	static private Double MOUNTAIN_BASE_DEF_SB0_SCALE = 0.5;
	static private Double MOUNTAIN_BASE_DEF_SB0_BIAS = 0.375;

	static private ScaleBias mountainBaseDef_sb0 = new ScaleBias(mountainBaseDef_rm0);
	static {
		mountainBaseDef_sb0.setScale(MOUNTAIN_BASE_DEF_SB0_SCALE);
		mountainBaseDef_sb0.setBias(MOUNTAIN_BASE_DEF_SB0_BIAS);
	}

	// 3: [River-valley module]: This ridged-multifractal-noise module generates
	// the river valleys. It has a much lower frequency than the mountain-
	// ridge module so that more mountain ridges will appear outside of the
	// valleys. Note that this noise module generates ridged-multifractal
	// noise using only one octave; this information will be important in the
	// next step.
	static private Double MOUNTAIN_BASE_DEF_RM1_FREQUENCY = 367.0;
	static private Integer MOUNTAIN_BASE_DEF_RM1_OCTAVE_COUNT = 1;

	static private RidgedMulti mountainBaseDef_rm1 = new RidgedMulti();
	static {
		mountainBaseDef_rm1.setSeed(CUR_SEED + 31);
		mountainBaseDef_rm1.setFrequency(MOUNTAIN_BASE_DEF_RM1_FREQUENCY);
		mountainBaseDef_rm1.setLacunarity(MOUNTAIN_LACUNARITY);
		mountainBaseDef_rm1.setOctaveCount(MOUNTAIN_BASE_DEF_RM1_OCTAVE_COUNT);
		mountainBaseDef_rm1.setNoiseQuality(NoiseQuality.QUALITY_BEST);
	}

	// 4: [Scaled-river-valley module]: Next, a scale/bias module applies a
	// scaling factor of -2.0 to the output value from the river-valley
	// module. This stretches the possible elevation values because one-
	// octave ridged-multifractal noise has a lower range of output values
	// than multiple-octave ridged-multifractal noise. The negative scaling
	// factor inverts the range of the output value, turning the ridges from
	// the river-valley module into valleys.
	static private Double MOUNTAIN_BASE_DEF_SB1_SCALE = -2.0;
	static private Double MOUNTAIN_BASE_DEF_SB1_BIAS = -0.5;

	static private ScaleBias mountainBaseDef_sb1 = new ScaleBias(mountainBaseDef_rm1);
	static {
		mountainBaseDef_sb1.setScale(MOUNTAIN_BASE_DEF_SB1_SCALE);
		mountainBaseDef_sb1.setBias(MOUNTAIN_BASE_DEF_SB1_BIAS);
	}

	static public Const mountainBaseDef_co = new Const();
	static {
		mountainBaseDef_co.setConstValue(-1.0); // wimpy ...
	}
	// 6: [Mountains-and-valleys module]: This blender module merges the
	// scaled-mountain-ridge module and the scaled-river-valley module
	// together. It causes the low-lying areas of the terrain to become
	// smooth, and causes the high-lying areas of the terrain to contain
	// ridges. To do this, it uses the scaled-river-valley module as the
	// control module, causing the low-flat module to appear in the lower
	// areas and causing the scaled-mountain-ridge module to appear in the
	// higher areas.

	static private Blend mountainBaseDef_bl = new Blend(mountainBaseDef_co, mountainBaseDef_sb0, mountainBaseDef_sb1);

	// 7: [Coarse-turbulence module]: This turbulence module warps the output
	// value from the mountain-and-valleys module, adding some coarse detail
	// to it.
	static private Double MOUNTAIN_BASE_DEF_TU0_FREQUENCY = 1337.0;
	static private Double MOUNTAIN_BASE_DEF_TU0_POWER_SCALAR0 = 1.0;
	static private Double MOUNTAIN_BASE_DEF_TU0_POWER_SCALAR1 = 6730.0 * MOUNTAINS_TWIST;
	static private Integer MOUNTAIN_BASE_DEF_TU0_ROUGHNESS = 4;
	static private Turbulence mountainBaseDef_tu0 = new Turbulence(mountainBaseDef_bl);
	static {
		mountainBaseDef_tu0.setSeed(CUR_SEED + 32);
		mountainBaseDef_tu0.setFrequency(MOUNTAIN_BASE_DEF_TU0_FREQUENCY);
		mountainBaseDef_tu0.setPower(MOUNTAIN_BASE_DEF_TU0_POWER_SCALAR0 / MOUNTAIN_BASE_DEF_TU0_POWER_SCALAR1);
		mountainBaseDef_tu0.setRoughness(MOUNTAIN_BASE_DEF_TU0_ROUGHNESS);
	}

	// 8: [Warped-mountains-and-valleys module]: This turbulence module warps
	// the output value from the coarse-turbulence module. This turbulence
	// has a higher frequency, but lower power, than the coarse-turbulence
	// module, adding some fine detail to it.
	static private Double MOUNTAIN_BASE_DEF_TU1_FREQUENCY = 21221.0;
	static private Double MOUNTAIN_BASE_DEF_TU1_POWER_SCALAR0 = 1.0;
	static private Double MOUNTAIN_BASE_DEF_TU1_POWER_SCALAR1 = 120157.0 * MOUNTAINS_TWIST;
	static private Integer MOUNTAIN_BASE_DEF_TU1_ROUGHNESS = 6;
	static private Turbulence mountainBaseDef_tu1 = new Turbulence(mountainBaseDef_tu0);
	static {
		mountainBaseDef_tu1.setSeed(CUR_SEED + 33);
		mountainBaseDef_tu1.setFrequency(MOUNTAIN_BASE_DEF_TU1_FREQUENCY);
		mountainBaseDef_tu1.setPower(MOUNTAIN_BASE_DEF_TU1_POWER_SCALAR0 / MOUNTAIN_BASE_DEF_TU1_POWER_SCALAR1);
		mountainBaseDef_tu1.setRoughness(MOUNTAIN_BASE_DEF_TU1_ROUGHNESS);
	}
	// 9:
	static private Cached mountainBaseDef = new Cached(mountainBaseDef_tu1);

	// //////////////////////////////////////////////////////////////////////////
	// Module subgroup: high mountainous terrain (5 noise modules)
	//
	// This subgroup generates the mountainous terrain that appears at high
	// elevations within the mountain ridges.
	//
	// -1.0 represents the lowest elevations and +1.0 represents the highest
	// elevations.
	//

	// 1: [Mountain-basis-0 module]: This ridged-multifractal-noise module,
	// along with the mountain-basis-1 module, generates the individual
	// mountains.
	static private Double MOUNTAINOUS_HIGH_RM0_FREQUENCY = 2371.0;
	static private Double MOUNTAINOUS_HIGH_RM0_LACUNARITY = MOUNTAIN_LACUNARITY;
	static private Integer MOUNTAINOUS_HIGH_RM0_OCTAVE_COUNT = 3;
	static private RidgedMulti mountainousHigh_rm0 = new RidgedMulti();
	static {
		mountainousHigh_rm0.setSeed(CUR_SEED + 40);
		mountainousHigh_rm0.setFrequency(MOUNTAINOUS_HIGH_RM0_FREQUENCY);
		mountainousHigh_rm0.setLacunarity(MOUNTAINOUS_HIGH_RM0_LACUNARITY);
		mountainousHigh_rm0.setOctaveCount(MOUNTAINOUS_HIGH_RM0_OCTAVE_COUNT);
		mountainousHigh_rm0.setNoiseQuality(NoiseQuality.QUALITY_BEST);
	}

	// 2: [Mountain-basis-1 module]: This ridged-multifractal-noise module,
	// along with the mountain-basis-0 module, generates the individual
	// mountains.
	static private Double MOUNTAINOUS_HIGH_RM1_FREQUENCY = 2341.0;
	static private Double MOUNTAINOUS_HIGH_RM1_LACUNARITY = MOUNTAIN_LACUNARITY;
	static private Integer MOUNTAINOUS_HIGH_RM1_OCTAVE_COUNT = 3;
	static private RidgedMulti mountainousHigh_rm1 = new RidgedMulti();
	static {
		mountainousHigh_rm1.setSeed(CUR_SEED + 41);
		mountainousHigh_rm1.setFrequency(MOUNTAINOUS_HIGH_RM1_FREQUENCY);
		mountainousHigh_rm1.setLacunarity(MOUNTAINOUS_HIGH_RM1_LACUNARITY);
		mountainousHigh_rm1.setOctaveCount(MOUNTAINOUS_HIGH_RM1_OCTAVE_COUNT);
		mountainousHigh_rm1.setNoiseQuality(NoiseQuality.QUALITY_BEST);
	}

	// 3: [High-mountains module]: Next, a maximum-value module causes more
	// mountains to appear at the expense of valleys. It does this by
	// ensuring that only the maximum of the output values from the two
	// ridged-multifractal-noise modules contribute to the output value of
	// this subgroup.
	static private Max mountainousHigh_ma = new Max(mountainousHigh_rm0, mountainousHigh_rm1);

	// 4: [Warped-high-mountains module]: This turbulence module warps the
	// output value from the high-mountains module, adding some detail to it.
	static private Double MOUNTAINOUS_HIGH_TU_FREQUENCY = 31511.0;
	static private Double MOUNTAINOUS_HIGH_TU_SCALAR1 = 1.0;
	static private Double MOUNTAINOUS_HIGH_TU_SCALAR2 = 180371.0;
	static private Double MOUNTAINOUS_HIGH_TU_POWER = MOUNTAINOUS_HIGH_TU_SCALAR1 / MOUNTAINOUS_HIGH_TU_SCALAR2
			* MOUNTAINS_TWIST;
	static private Integer MOUNTAINOUS_HIGH_TU_ROUGHNESS = 4;
	static private Turbulence mountainousHigh_tu = new Turbulence(mountainousHigh_ma);
	static {
		mountainousHigh_tu.setSeed(CUR_SEED + 42);
		mountainousHigh_tu.setFrequency(MOUNTAINOUS_HIGH_TU_FREQUENCY);
		mountainousHigh_tu.setPower(MOUNTAINOUS_HIGH_TU_POWER);
		mountainousHigh_tu.setRoughness(MOUNTAINOUS_HIGH_TU_ROUGHNESS);
	}
	// 5:
	private static Cached mountainousHigh = new Cached(mountainousHigh_tu);

	// //////////////////////////////////////////////////////////////////////////
	// Module subgroup: low mountainous terrain (4 noise modules)
	//
	// This subgroup generates the mountainous terrain that appears at low
	// elevations within the river valleys.
	//
	// -1.0 represents the lowest elevations and +1.0 represents the highest
	// elevations.
	//

	// 1: [Lowland-basis-0 module]: This ridged-multifractal-noise module,
	// along with the lowland-basis-1 module, produces the low mountainous
	// terrain.

	static private Double MOUNTAINOUS_LOW_RM0_FREQUENCY = 1381.0;
	static private Double MOUNTAINOUS_LOW_RM0_LACUNARITY = MOUNTAIN_LACUNARITY;
	static private Integer MOUNTAINOUS_LOW_RM0_OCTAVE_COUNT = 8;
	static private RidgedMulti mountainousLow_rm0 = new RidgedMulti();
	static {
		mountainousLow_rm0.setSeed(CUR_SEED + 50);
		mountainousLow_rm0.setFrequency(MOUNTAINOUS_LOW_RM0_FREQUENCY);
		mountainousLow_rm0.setLacunarity(MOUNTAINOUS_LOW_RM0_LACUNARITY);
		mountainousLow_rm0.setOctaveCount(MOUNTAINOUS_LOW_RM0_OCTAVE_COUNT);
	}
	// 1: [Lowland-basis-1 module]: This ridged-multifractal-noise module,
	// along with the lowland-basis-0 module, produces the low mountainous
	// terrain.
	static private Double MOUNTAINOUS_LOW_RM1_FREQUENCY = 1427.0;
	static private Double MOUNTAINOUS_LOW_RM1_LACUNARITY = MOUNTAIN_LACUNARITY;
	static private Integer MOUNTAINOUS_LOW_RM1_OCTAVE_COUNT = 8;
	static private RidgedMulti mountainousLow_rm1 = new RidgedMulti();
	static {
		mountainousLow_rm1.setSeed(CUR_SEED + 51);
		mountainousLow_rm1.setFrequency(MOUNTAINOUS_LOW_RM1_FREQUENCY);
		mountainousLow_rm1.setLacunarity(MOUNTAINOUS_LOW_RM1_LACUNARITY);
		mountainousLow_rm1.setOctaveCount(MOUNTAINOUS_LOW_RM1_OCTAVE_COUNT);
	}

	// 3: [Low-mountainous-terrain module]: This multiplication module combines
	// the output values from the two ridged-multifractal-noise modules.
	// This causes the following to appear in the resulting terrain:
	// - Cracks appear when two negative output values are multiplied
	// together.
	// - Flat areas appear when a positive and a negative output value are
	// multiplied together.
	// - Ridges appear when two positive output values are multiplied
	// together.
	private static Multiply mountainousLow_mu = new Multiply(mountainousLow_rm0, mountainousLow_rm1);

	private static Cached mountainousLow = new Cached(mountainousLow_mu);

	// //////////////////////////////////////////////////////////////////////////
	// Module subgroup: mountainous terrain (7 noise modules)
	//
	// This subgroup generates the final mountainous terrain by combining the
	// high-mountainous-terrain subgroup with the low-mountainous-terrain
	// subgroup.
	//
	// -1.0 represents the lowest elevations and +1.0 represents the highest
	// elevations.
	//

	// 1: [Scaled-low-mountainous-terrain module]: First, this scale/bias module
	// scales the output value from the low-mountainous-terrain subgroup to a
	// very low value and biases it towards -1.0. This results in the low
	// mountainous areas becoming more-or-less flat with little variation.
	// This will also result in the low mountainous areas appearing at the
	// lowest elevations in this subgroup.
	static private Double MOUNTAINOUS_TERRAIN_SB0_SCALE = 0.03125;
	static private Double MOUNTAINOUS_TERRAIN_SB0_BIAS = -0.96875;
	static private ScaleBias mountainousTerrain_sb0 = new ScaleBias(mountainousLow);
	static {
		mountainousTerrain_sb0.setScale(MOUNTAINOUS_TERRAIN_SB0_SCALE);
		mountainousTerrain_sb0.setBias(MOUNTAINOUS_TERRAIN_SB0_BIAS);
	}

	// 2: [Scaled-high-mountainous-terrain module]: Next, this scale/bias module
	// scales the output value from the high-mountainous-terrain subgroup to
	// 1/4 of its initial value and biases it so that its output value is
	// usually positive.
	static private Double MOUNTAINOUS_TERRAIN_SB1_SCALE = 0.25;
	static private Double MOUNTAINOUS_TERRAIN_SB1_BIAS = 0.25;
	static private ScaleBias mountainousTerrain_sb1 = new ScaleBias(mountainousHigh);
	static {
		mountainousTerrain_sb1.setScale(MOUNTAINOUS_TERRAIN_SB1_SCALE);
		mountainousTerrain_sb1.setBias(MOUNTAINOUS_TERRAIN_SB1_BIAS);
	}

	// 3: [Added-high-mountainous-terrain module]: This addition module adds the
	// output value from the scaled-high-mountainous-terrain module to the
	// output value from the mountain-base-definition subgroup. Mountains
	// now appear all over the terrain.
	static private Add mountainousTerrain_ad = new Add(mountainousTerrain_sb1, mountainBaseDef);

	// 4: [Combined-mountainous-terrain module]: Note that at this point, the
	// entire terrain is covered in high mountainous terrain, even at the low
	// elevations. To make sure the mountains only appear at the higher
	// elevations, this selector module causes low mountainous terrain to
	// appear at the low elevations (within the valleys) and the high
	// mountainous terrain to appear at the high elevations (within the
	// ridges.) To do this, this noise module selects the output value from
	// the added-high-mountainous-terrain module if the output value from the
	// mountain-base-definition subgroup is higher than a set amount.
	// Otherwise, this noise module selects the output value from the scaled-
	// low-mountainous-terrain module.

	// / Sets the lower and upper bounds of the selection range.
	static private Double MOUNTAINOUS_TERRAIN_SE_BOUNDS_PARAM_0 = -0.5;
	static private Double MOUNTAINOUS_TERRAIN_SE_BOUNDS_PARAM_1 = 999.5;
	// / Sets the falloff value at the edge transition.
	static private Double MOUNTAINOUS_TERRAIN_SE_EDGE_FALLOFF = 0.5;
	static private Select mountainousTerrain_se = new Select(mountainousTerrain_sb0, mountainousTerrain_ad,
			mountainBaseDef);
	static {
		mountainousTerrain_se.setBounds(MOUNTAINOUS_TERRAIN_SE_BOUNDS_PARAM_0, MOUNTAINOUS_TERRAIN_SE_BOUNDS_PARAM_1);
		mountainousTerrain_se.setEdgeFalloff(MOUNTAINOUS_TERRAIN_SE_EDGE_FALLOFF);
	}
	// 5: [Scaled-mountainous-terrain-module]: This scale/bias module slightly
	// reduces the range of the output value from the combined-mountainous-
	// terrain module, decreasing the heights of the mountain peaks.
	static private Double MOUNTAINOUS_TERRAIN_SB2_SCALE = 0.8;
	static private Double MOUNTAINOUS_TERRAIN_SB2_BIAS = 0.0;
	static private ScaleBias mountainousTerrain_sb2 = new ScaleBias(mountainousTerrain_se);
	static {
		mountainousTerrain_sb2.setScale(MOUNTAINOUS_TERRAIN_SB2_SCALE);
		mountainousTerrain_sb2.setBias(MOUNTAINOUS_TERRAIN_SB2_BIAS);
	}
	// 6: [Glaciated-mountainous-terrain-module]: This exponential-curve module
	// applies an exponential curve to the output value from the scaled-
	// mountainous-terrain module. This causes the slope of the mountains to
	// smoothly increase towards higher elevations, as if a glacier grinded
	// out those mountains. This exponential-curve module expects the output
	// value to range from -1.0 to +1.0.
	static private Exponent mountainousTerrain_ex = new Exponent(mountainousTerrain_sb2);
	static {
		mountainousTerrain_ex.setExponent(MOUNTAIN_GLACIATION);
	}
	static private Cached mountainousTerrain = new Cached(mountainousTerrain_ex);

	// //////////////////////////////////////////////////////////////////////////
	// Module group: hilly terrain
	// //////////////////////////////////////////////////////////////////////////

	// //////////////////////////////////////////////////////////////////////////
	// Module subgroup: hilly terrain (11 noise modules)
	//
	// This subgroup generates the hilly terrain.
	//
	// -1.0 represents the lowest elevations and +1.0 represents the highest
	// elevations.
	//

	// 1: [Hills module]: This billow-noise module generates the hills.
	private static Double HILLY_TERRAIN_BI_FREQUENCY = 1663.0;
	private static Double HILLY_TERRAIN_BI_PERSISTENCE = 0.5;
	private static Integer HILLY_TERRAIN_BI_OCTAVE_COUNT = 6;
	private static Billow hillyTerrain_bi = new Billow();
	static {
		hillyTerrain_bi.setSeed(CUR_SEED + 60);
		hillyTerrain_bi.setFrequency(HILLY_TERRAIN_BI_FREQUENCY);
		hillyTerrain_bi.setPersistence(HILLY_TERRAIN_BI_PERSISTENCE);
		hillyTerrain_bi.setLacunarity(HILLS_LACUNARITY);
		hillyTerrain_bi.setOctaveCount(HILLY_TERRAIN_BI_OCTAVE_COUNT);
		hillyTerrain_bi.setNoiseQuality(NoiseQuality.QUALITY_BEST);
	}

	// 2: [Scaled-hills module]: Next, a scale/bias module scales the output
	// value from the hills module so that its hilltops are not too high.
	// The reason for this is that these hills are eventually added to the
	// river valleys (see below.)
	static private Double HILLY_TERRAIN_SB0_SCALE = 0.5;
	static private Double HILLY_TERRAIN_SB0_BIAS = 0.5;
	static private ScaleBias hillyTerrain_sb0 = new ScaleBias(hillyTerrain_bi);
	static {
		hillyTerrain_sb0.setScale(HILLY_TERRAIN_SB0_SCALE);
		hillyTerrain_sb0.setBias(HILLY_TERRAIN_SB0_BIAS);
	}

	// 3: [River-valley module]: This ridged-multifractal-noise module generates
	// the river valleys. It has a much lower frequency so that more hills
	// will appear in between the valleys. Note that this noise module
	// generates ridged-multifractal noise using only one octave; this
	// information will be important in the next step.
	static private Double HILLY_TERRAIN_RM_FREQUENCY = 367.5;
	static private Integer HILLY_TERRAIN_RM_OCTAVE_COUNT = 1;
	static private RidgedMulti hillyTerrain_rm = new RidgedMulti();
	static {
		hillyTerrain_rm.setSeed(CUR_SEED + 61);
		hillyTerrain_rm.setFrequency(HILLY_TERRAIN_RM_FREQUENCY);
		hillyTerrain_rm.setLacunarity(HILLS_LACUNARITY);
		hillyTerrain_rm.setNoiseQuality(NoiseQuality.QUALITY_BEST);
		hillyTerrain_rm.setOctaveCount(HILLY_TERRAIN_RM_OCTAVE_COUNT);
	}
	// 4: [Scaled-river-valley module]: Next, a scale/bias module applies a
	// scaling factor of -2.0 to the output value from the river-valley
	// module. This stretches the possible elevation values because one-
	// octave ridged-multifractal noise has a lower range of output values
	// than multiple-octave ridged-multifractal noise. The negative scaling
	// factor inverts the range of the output value, turning the ridges from
	// the river-valley module into valleys.
	static private Double HILLY_TERRAIN_SB1_SCALE = -2.0;
	static private Double HILLY_TERRAIN_SB1_BIAS = -0.5;
	static private ScaleBias hillyTerrain_sb1 = new ScaleBias(hillyTerrain_rm);
	static {
		hillyTerrain_sb1.setScale(HILLY_TERRAIN_SB1_SCALE);
		hillyTerrain_sb1.setBias(HILLY_TERRAIN_SB1_BIAS);
	}

	// 5:
	static private Double HILLY_TERRAIN_CO = -1.0;
	static private Const hillyTerrain_co = new Const();
	static {
		hillyTerrain_co.setConstValue(HILLY_TERRAIN_CO);
	}

	// 6: [Mountains-and-valleys module]: This blender module merges the
	// scaled-hills module and the scaled-river-valley module together. It
	// causes the low-lying areas of the terrain to become smooth, and causes
	// the high-lying areas of the terrain to contain hills. To do this, it
	// uses the scaled-hills module as the control module, causing the low-
	// flat module to appear in the lower areas and causing the scaled-river-
	// valley module to appear in the higher areas.

	static private Blend hillyTerrain_bl = new Blend(hillyTerrain_co, hillyTerrain_sb0, hillyTerrain_sb1);

	// 7: [Scaled-hills-and-valleys module]: This scale/bias module slightly
	// reduces the range of the output value from the hills-and-valleys
	// module, decreasing the heights of the hilltops.

	static private Double HILLY_TERRAIN_SB2_SCALE = 0.75;
	static private Double HILLY_TERRAIN_SB2_BIAS = -0.25;
	static private ScaleBias hillyTerrain_sb2 = new ScaleBias(hillyTerrain_bl);
	static {
		hillyTerrain_sb2.setScale(HILLY_TERRAIN_SB2_SCALE);
		hillyTerrain_sb2.setBias(HILLY_TERRAIN_SB2_BIAS);
	}

	// 8: [Increased-slope-hilly-terrain module]: To increase the hill slopes at
	// higher elevations, this exponential-curve module applies an
	// exponential curve to the output value the scaled-hills-and-valleys
	// module. This exponential-curve module expects the input value to
	// range from -1.0 to 1.0.
	static private Double HILLY_TERRAIN_EX = 1.375;
	static private Exponent hillyTerrain_ex = new Exponent(hillyTerrain_sb2);
	static {
		hillyTerrain_ex.setExponent(HILLY_TERRAIN_EX);
	}

	// 9: [Coarse-turbulence module]: This turbulence module warps the output
	// value from the increased-slope-hilly-terrain module, adding some
	// coarse detail to it.
	static private Double HILLY_TERRAIN_TU0_FREQUENCY = 1531.0;
	static private Double HILLY_TERRAIN_TU0_SCALAR0 = 1.0;
	static private Double HILLY_TERRAIN_TU0_SCALAR1 = 16921.0;
	static private Integer HILLY_TERRAIN_TU0_ROUGHNESS = 4;

	static private Turbulence hillyTerrain_tu0 = new Turbulence(hillyTerrain_ex);
	static {
		hillyTerrain_tu0.setSeed(CUR_SEED + 62);
		hillyTerrain_tu0.setFrequency(HILLY_TERRAIN_TU0_FREQUENCY);
		hillyTerrain_tu0.setPower(HILLY_TERRAIN_TU0_SCALAR0 / HILLY_TERRAIN_TU0_SCALAR1 * HILLS_TWIST);
		hillyTerrain_tu0.setRoughness(HILLY_TERRAIN_TU0_ROUGHNESS);
	}

	// 10: [Warped-hilly-terrain module]: This turbulence module warps the
	// output value from the coarse-turbulence module. This turbulence has
	// a higher frequency, but lower power, than the coarse-turbulence
	// module, adding some fine detail to it.

	static private Double HILLY_TERRAIN_TU1_FREQUENCY = 21617.0;
	static private Double HILLY_TERRAIN_TU1_SCALAR0 = 1.0;
	static private Double HILLY_TERRAIN_TU1_SCALAR1 = 117529.0;
	static private Integer HILLY_TERRAIN_TU1_ROUGHNESS = 6;

	static private Turbulence hillyTerrain_tu1 = new Turbulence(hillyTerrain_tu0);
	static {
		hillyTerrain_tu1.setSeed(CUR_SEED + 63);
		hillyTerrain_tu1.setFrequency(HILLY_TERRAIN_TU1_FREQUENCY);
		hillyTerrain_tu1.setPower(HILLY_TERRAIN_TU1_SCALAR0 / HILLY_TERRAIN_TU1_SCALAR1 * HILLS_TWIST);
		hillyTerrain_tu1.setRoughness(HILLY_TERRAIN_TU1_ROUGHNESS);
	}

	// 11:
	static private Cached hillyTerrain = new Cached(hillyTerrain_tu1);

	// //////////////////////////////////////////////////////////////////////////
	// Module group: plains terrain
	// //////////////////////////////////////////////////////////////////////////

	// //////////////////////////////////////////////////////////////////////////
	// Module subgroup: plains terrain (7 noise modules)
	//
	// This subgroup generates the plains terrain.
	//
	// Because this subgroup will eventually be flattened considerably, the
	// types and combinations of noise modules that generate the plains are not
	// really that important; they only need to "look" interesting.
	//
	// -1.0 represents the lowest elevations and +1.0 represents the highest
	// elevations.
	//

	// 1: [Plains-basis-0 module]: This billow-noise module, along with the
	// plains-basis-1 module, produces the plains.
	private static Double PLAINS_TERRAIN_BI0_FREQUENCY = 1097.0;
	private static Double PLAINS_TERRAIN_BI0_PERSISTENCE = 0.5;
	private static Integer PLAINS_TERRAIN_BI0_OCTAVE_COUNT = 8;
	private static Billow plainsTerrain_bi0 = new Billow();
	static {
		plainsTerrain_bi0.setSeed(CUR_SEED + 70);
		plainsTerrain_bi0.setFrequency(PLAINS_TERRAIN_BI0_FREQUENCY);
		plainsTerrain_bi0.setPersistence(PLAINS_TERRAIN_BI0_PERSISTENCE);
		plainsTerrain_bi0.setLacunarity(PLAINS_LACUNARITY);
		plainsTerrain_bi0.setOctaveCount(PLAINS_TERRAIN_BI0_OCTAVE_COUNT);
		plainsTerrain_bi0.setNoiseQuality(NoiseQuality.QUALITY_BEST);
	}

	// 2: [Positive-plains-basis-0 module]: This scale/bias module makes the
	// output value from the plains-basis-0 module positive since this output
	// value will be multiplied together with the positive-plains-basis-1
	// module.
	static private Double PLAINS_TERRAIN_SB0_SCALE = 0.5;
	static private Double PLAINS_TERRAIN_SB0_BIAS = 0.5;
	static private ScaleBias plainsTerrain_sb0 = new ScaleBias(plainsTerrain_bi0);
	static {
		plainsTerrain_sb0.setScale(PLAINS_TERRAIN_SB0_SCALE);
		plainsTerrain_sb0.setBias(PLAINS_TERRAIN_SB0_BIAS);
	}

	// 3: [Plains-basis-1 module]: This billow-noise module, along with the
	// plains-basis-2 module, produces the plains.

	private static Double PLAINS_TERRAIN_BI1_FREQUENCY = 1319.0;
	private static Double PLAINS_TERRAIN_BI1_PERSISTENCE = 0.5;
	private static Integer PLAINS_TERRAIN_BI1_OCTAVE_COUNT = 8;
	private static Billow plainsTerrain_bi1 = new Billow();
	static {
		plainsTerrain_bi1.setSeed(CUR_SEED + 71);
		plainsTerrain_bi1.setFrequency(PLAINS_TERRAIN_BI1_FREQUENCY);
		plainsTerrain_bi1.setPersistence(PLAINS_TERRAIN_BI1_PERSISTENCE);
		plainsTerrain_bi1.setLacunarity(PLAINS_LACUNARITY);
		plainsTerrain_bi1.setOctaveCount(PLAINS_TERRAIN_BI1_OCTAVE_COUNT);
		plainsTerrain_bi1.setNoiseQuality(NoiseQuality.QUALITY_BEST);
	}

	// 4: [Positive-plains-basis-1 module]: This scale/bias module makes the
	// output value from the plains-basis-1 module positive since this output
	// value will be multiplied together with the positive-plains-basis-0
	// module.
	static private Double PLAINS_TERRAIN_SB1_SCALE = 0.5;
	static private Double PLAINS_TERRAIN_SB1_BIAS = 0.5;
	static private ScaleBias plainsTerrain_sb1 = new ScaleBias(plainsTerrain_bi1);
	static {
		plainsTerrain_sb1.setScale(PLAINS_TERRAIN_SB1_SCALE);
		plainsTerrain_sb1.setBias(PLAINS_TERRAIN_SB1_BIAS);
	}

	// 5: [Combined-plains-basis module]: This multiplication module combines
	// the two plains basis modules together.
	static private Multiply plainsTerrain_mu = new Multiply(plainsTerrain_sb0, plainsTerrain_sb1);

	// 6: [Rescaled-plains-basis module]: This scale/bias module maps the output
	// value that ranges from 0.0 to 1.0 back to a value that ranges from
	// -1.0 to +1.0.
	static private Double PLAINS_TERRAIN_SB2_SCALE = 2.0;
	static private Double PLAINS_TERRAIN_SB2_BIAS = -1.0;
	static private ScaleBias plainsTerrain_sb2 = new ScaleBias(plainsTerrain_mu);
	static {
		plainsTerrain_sb2.setScale(PLAINS_TERRAIN_SB2_SCALE);
		plainsTerrain_sb2.setBias(PLAINS_TERRAIN_SB2_BIAS);
	}

	// 7:
	static private Cached plainsTerrain = new Cached(plainsTerrain_sb2);

	// //////////////////////////////////////////////////////////////////////////
	// Module group: badlands terrain
	// //////////////////////////////////////////////////////////////////////////

	// //////////////////////////////////////////////////////////////////////////
	// Module subgroup: badlands sand (6 noise modules)
	//
	// This subgroup generates the sandy terrain for the badlands.
	//
	// -1.0 represents the lowest elevations and +1.0 represents the highest
	// elevations.
	//

	// 1: [Sand-dunes module]: This ridged-multifractal-noise module generates
	// sand dunes. This ridged-multifractal noise is generated with a single
	// octave, which makes very smooth dunes.
	static private Double BADLANDS_SAND_RM_FREQUENCY = 6163.5;
	static private Integer BADLANDS_SAND_RM_OCTAVE_COUNT = 1;
	static private RidgedMulti badlandsSand_rm = new RidgedMulti();
	static {
		badlandsSand_rm.setSeed(CUR_SEED + 80);
		badlandsSand_rm.setFrequency(BADLANDS_SAND_RM_FREQUENCY);
		badlandsSand_rm.setLacunarity(BADLANDS_LACUNARITY);
		badlandsSand_rm.setNoiseQuality(NoiseQuality.QUALITY_BEST);
		badlandsSand_rm.setOctaveCount(BADLANDS_SAND_RM_OCTAVE_COUNT);
	}

	// 2: [Scaled-sand-dunes module]: This scale/bias module shrinks the dune
	// heights by a small amount. This is necessary so that the subsequent
	// noise modules in this subgroup can add some detail to the dunes.

	static private Double BADLANDS_SAND_SB0_SCALE = 0.875;
	static private Double BADLANDS_SAND_SB0_BIAS = 0.0;

	static private ScaleBias badlandsSand_sb0 = new ScaleBias(badlandsSand_rm);
	static {
		badlandsSand_sb0.setScale(BADLANDS_SAND_SB0_SCALE);
		badlandsSand_sb0.setBias(BADLANDS_SAND_SB0_BIAS);
	}

	// 3: [Dune-detail module]: This noise module uses Voronoi polygons to
	// generate the detail to add to the dunes. By enabling the distance
	// algorithm, small polygonal pits are generated; the edges of the pits
	// are joined to the edges of nearby pits.

	// / The frequency determines the size of the Voronoi cells and the
	// / distance between these cells.
	static private Double BADLANDS_SAND_VO_FREQUENCY = 16183.25;
	// / This noise module assigns each Voronoi cell with a random constant
	// / value from a coherent-noise function. The <i>displacement
	// / value</i> controls the range of random values to assign to each
	// / cell. The range of random values is +/- the displacement value.
	static private Double BADLANDS_SAND_VO_DISPLACEMWNT = 0.0;

	static private Voronoi badlandsSand_vo = new Voronoi();
	static {
		badlandsSand_vo.setSeed(CUR_SEED + 81);
		badlandsSand_vo.setFrequency(BADLANDS_SAND_VO_FREQUENCY);
		badlandsSand_vo.setDisplacement(BADLANDS_SAND_VO_DISPLACEMWNT);
		badlandsSand_vo.enableDistance(Boolean.TRUE);
	}

	// 4: [Scaled-dune-detail module]: This scale/bias module shrinks the dune
	// details by a large amount. This is necessary so that the subsequent
	// noise modules in this subgroup can add this detail to the sand-dunes
	// module.
	static private Double BADLANDS_SAND_SB1_SCALE = 0.25;
	static private Double BADLANDS_SAND_SB1_BIAS = 0.25;

	static private ScaleBias badlandsSand_sb1 = new ScaleBias(badlandsSand_vo);
	static {
		badlandsSand_sb1.setScale(BADLANDS_SAND_SB1_SCALE);
		badlandsSand_sb1.setBias(BADLANDS_SAND_SB1_BIAS);
	}

	// 5: [Dunes-with-detail module]: This addition module combines the scaled-
	// sand-dunes module with the scaled-dune-detail module.
	static private Add badlandsSand_ad = new Add(badlandsSand_sb0, badlandsSand_sb1);

	// 6:
	static private Cached badlandsSand = new Cached(badlandsSand_ad);

	// //////////////////////////////////////////////////////////////////////////
	// Module subgroup: badlands cliffs (7 noise modules)
	//
	// This subgroup generates the cliffs for the badlands.
	//
	// -1.0 represents the lowest elevations and +1.0 represents the highest
	// elevations.
	//

	// 1: [Cliff-basis module]: This Perlin-noise module generates some coherent
	// noise that will be used to generate the cliffs.
	static private Double BADLANDS_CLIFFS_PE_FREQUENCY = CONTINENT_FREQUENCY * 839;
	static private Double BADLANDS_CLIFFS_PE_PERSISTENCE = 0.5;
	static private Integer BADLANDS_CLIFFS_PE_OCTAVE_COUNT = 6;
	static private Perlin badlandsCliffs_pe = new Perlin();
	static {
		badlandsCliffs_pe.setSeed(CUR_SEED + 90);
		badlandsCliffs_pe.setFrequency(BADLANDS_CLIFFS_PE_FREQUENCY);
		badlandsCliffs_pe.setPersistence(BADLANDS_CLIFFS_PE_PERSISTENCE);
		badlandsCliffs_pe.setLacunarity(BADLANDS_LACUNARITY);
		badlandsCliffs_pe.setOctaveCount(BADLANDS_CLIFFS_PE_OCTAVE_COUNT);
		badlandsCliffs_pe.setNoiseQuality(NoiseQuality.QUALITY_STD);
	}

	// 2: [Cliff-shaping module]: Next, this curve module applies a curve to the
	// output value from the cliff-basis module. This curve is initially
	// very shallow, but then its slope increases sharply. At the highest
	// elevations, the curve becomes very flat again. This produces the
	// stereotypical Utah-style desert cliffs.

	static private Curve badlandsCliffs_cu = new Curve(badlandsCliffs_pe);
	static {
		badlandsCliffs_cu.addControlPoint(-2.0000, -2.0000);
		badlandsCliffs_cu.addControlPoint(-1.0000, -1.2500);
		badlandsCliffs_cu.addControlPoint(-0.0000, -0.7500);
		badlandsCliffs_cu.addControlPoint(0.5000, -0.2500);
		badlandsCliffs_cu.addControlPoint(0.6250, 0.8750);
		badlandsCliffs_cu.addControlPoint(0.7500, 1.0000);
		badlandsCliffs_cu.addControlPoint(2.0000, 1.2500);
	}

	// 3: [Clamped-cliffs module]: This clamping module makes the tops of the
	// cliffs very flat by clamping the output value from the cliff-shaping
	// module so that the tops of the cliffs are very flat.
	static private Double BADLANDS_CLIFFS_CL_LOWER_BOUND = -999.125;
	static private Double BADLANDS_CLIFFS_CL_UPPER_BOUND = 0.875;

	static private Clamp badlandsCliffs_cl = new Clamp(badlandsCliffs_cu);
	static {
		badlandsCliffs_cl.setBounds(BADLANDS_CLIFFS_CL_LOWER_BOUND, BADLANDS_CLIFFS_CL_UPPER_BOUND);
	}

	// 4: [Terraced-cliffs module]: Next, this terracing module applies some
	// terraces to the clamped-cliffs module in the lower elevations before
	// the sharp cliff transition.

	static private Terrace badlandsCliffs_te = new Terrace(badlandsCliffs_cl);
	static {
		badlandsCliffs_te.addControlPoint(-1.0000);
		badlandsCliffs_te.addControlPoint(-0.8750);
		badlandsCliffs_te.addControlPoint(-0.7500);
		badlandsCliffs_te.addControlPoint(-0.5000);
		badlandsCliffs_te.addControlPoint(1.0000);
	}

	// 5: [Coarse-turbulence module]: This turbulence module warps the output
	// value from the terraced-cliffs module, adding some coarse detail to
	// it.
	static private Double BADLANDS_CLIFFS_TU0_FREQUENCY = 16111.0;
	static private Double BADLANDS_CLIFFS_TU0_SCALAR0 = 1.0;
	static private Double BADLANDS_CLIFFS_TU0_SCALAR1 = 141539.0;
	static private Integer BADLANDS_CLIFFS_TU0_ROUGHNESS = 3;
	static private Turbulence badlandsCliffs_tu0 = new Turbulence(badlandsCliffs_te);
	static {
		badlandsCliffs_tu0.setSeed(CUR_SEED + 91);
		badlandsCliffs_tu0.setFrequency(BADLANDS_CLIFFS_TU0_FREQUENCY);
		badlandsCliffs_tu0.setPower(BADLANDS_CLIFFS_TU0_SCALAR0 / BADLANDS_CLIFFS_TU0_SCALAR1 * BADLANDS_TWIST);
		badlandsCliffs_tu0.setRoughness(BADLANDS_CLIFFS_TU0_ROUGHNESS);
	}

	// 6: [Warped-cliffs module]: This turbulence module warps the output value
	// from the coarse-turbulence module. This turbulence has a higher
	// frequency, but lower power, than the coarse-turbulence module, adding
	// some fine detail to it.
	static private Double BADLANDS_CLIFFS_TU1_FREQUENCY = 36107.0;
	static private Double BADLANDS_CLIFFS_TU1_SCALAR0 = 1.0;
	static private Double BADLANDS_CLIFFS_TU1_SCALAR1 = 211543.0;
	static private Integer BADLANDS_CLIFFS_TU1_ROUGHNESS = 3;
	static private Turbulence badlandsCliffs_tu1 = new Turbulence(badlandsCliffs_tu0);
	static {
		badlandsCliffs_tu1.setSeed(CUR_SEED + 92);
		badlandsCliffs_tu1.setFrequency(BADLANDS_CLIFFS_TU1_FREQUENCY);
		badlandsCliffs_tu1.setPower(BADLANDS_CLIFFS_TU1_SCALAR0 / BADLANDS_CLIFFS_TU1_SCALAR1 * BADLANDS_TWIST);
		badlandsCliffs_tu1.setRoughness(BADLANDS_CLIFFS_TU1_ROUGHNESS);
	}

	// 7:
	static private Cached badlandsCliffs = new Cached(badlandsCliffs_tu1);

	// //////////////////////////////////////////////////////////////////////////
	// Module subgroup: badlands terrain (3 noise modules)
	//
	// Generates the final badlands terrain.
	//
	// Using a scale/bias module, the badlands sand is flattened considerably,
	// then the sand elevations are lowered to around -1.0. The maximum value
	// from the flattened sand module and the cliff module contributes to the
	// final elevation. This causes sand to appear at the low elevations since
	// the sand is slightly higher than the cliff base.
	//
	// -1.0 represents the lowest elevations and +1.0 represents the highest
	// elevations.
	//

	// 1: [Scaled-sand-dunes module]: This scale/bias module considerably
	// flattens the output value from the badlands-sands subgroup and lowers
	// this value to near -1.0.
	static private Double BADLANDS_TERRAIN_SB_SCALE = 0.25;
	static private Double BADLANDS_TERRAIN_SB_BIAS = -0.75;
	static private ScaleBias badlandsTerrain_sb = new ScaleBias(badlandsSand);
	static {
		badlandsTerrain_sb.setScale(BADLANDS_TERRAIN_SB_SCALE);
		badlandsTerrain_sb.setScale(BADLANDS_TERRAIN_SB_BIAS);
	}

	// 2: [Dunes-and-cliffs module]: This maximum-value module causes the dunes
	// to appear in the low areas and the cliffs to appear in the high areas.
	// It does this by selecting the maximum of the output values from the
	// scaled-sand-dunes module and the badlands-cliffs subgroup.

	static private Max badlandsTerrain_ma = new Max(badlandsCliffs, badlandsTerrain_sb);

	// 3:
	static private Cached badlandsTerrain = new Cached(badlandsTerrain_ma);

	// //////////////////////////////////////////////////////////////////////////
	// Module group: river positions
	// //////////////////////////////////////////////////////////////////////////

	// //////////////////////////////////////////////////////////////////////////
	// Module subgroup: river positions (7 noise modules)
	//
	// This subgroup generates the river positions.
	//
	// -1.0 represents the lowest elevations and +1.0 represents the highest
	// elevations.
	//

	// 1: [Large-river-basis module]: This ridged-multifractal-noise module
	// creates the large, deep rivers.
	static private Double RIVER_POSITIONS_RM0_FREQUENCY = 18.75;
	static private Integer RIVER_POSITIONS_RM0_OCTAVE_COUNT = 1;
	static private RidgedMulti riverPositions_rm0 = new RidgedMulti();
	static {
		riverPositions_rm0.setSeed(CUR_SEED + 100);
		riverPositions_rm0.setFrequency(RIVER_POSITIONS_RM0_FREQUENCY);
		riverPositions_rm0.setLacunarity(CONTINENT_LACUNARITY);
		riverPositions_rm0.setOctaveCount(RIVER_POSITIONS_RM0_OCTAVE_COUNT);
		riverPositions_rm0.setNoiseQuality(NoiseQuality.QUALITY_BEST);
	}

	// 2: [Large-river-curve module]: This curve module applies a curve to the
	// output value from the large-river-basis module so that the ridges
	// become inverted. This creates the rivers. This curve also compresses
	// the edge of the rivers, producing a sharp transition from the land to
	// the river bottom.
	static private Curve riverPositions_cu0 = new Curve(riverPositions_rm0);
	static {
		riverPositions_cu0.addControlPoint(-2.000, 2.000);
		riverPositions_cu0.addControlPoint(-1.000, 1.000);
		riverPositions_cu0.addControlPoint(-0.125, 0.875);
		riverPositions_cu0.addControlPoint(0.000, -1.000);
		riverPositions_cu0.addControlPoint(1.000, -1.500);
		riverPositions_cu0.addControlPoint(2.000, -2.000);
	}

	// / 3: [Small-river-basis module]: This ridged-multifractal-noise module
	// creates the small, shallow rivers.
	static private Double RIVER_POSITIONS_RM1_FREQUENCY = 43.25;
	static private Integer RIVER_POSITIONS_RM1_OCTAVE_COUNT = 1;
	static private RidgedMulti riverPositions_rm1 = new RidgedMulti();
	static {
		riverPositions_rm1.setSeed(CUR_SEED + 101);
		riverPositions_rm1.setFrequency(RIVER_POSITIONS_RM1_FREQUENCY);
		riverPositions_rm1.setLacunarity(CONTINENT_LACUNARITY);
		riverPositions_rm1.setOctaveCount(RIVER_POSITIONS_RM1_OCTAVE_COUNT);
		riverPositions_rm1.setNoiseQuality(NoiseQuality.QUALITY_BEST);
	}

	// 4: [Small-river-curve module]: This curve module applies a curve to the
	// output value from the small-river-basis module so that the ridges
	// become inverted. This creates the rivers. This curve also compresses
	// the edge of the rivers, producing a sharp transition from the land to
	// the river bottom.
	static private Curve riverPositions_cu1 = new Curve(riverPositions_rm1);
	static {
		riverPositions_cu1.addControlPoint(-2.000, 2.0000);
		riverPositions_cu1.addControlPoint(-1.000, 1.5000);
		riverPositions_cu1.addControlPoint(-0.125, 1.4375);
		riverPositions_cu1.addControlPoint(0.000, 0.5000);
		riverPositions_cu1.addControlPoint(1.000, 0.2500);
		riverPositions_cu1.addControlPoint(2.000, 0.0000);
	}

	// 5: [Combined-rivers module]: This minimum-value module causes the small
	// rivers to cut into the large rivers. It does this by selecting the
	// minimum output values from the large-river-curve module and the small-
	// river-curve module.
	static private Min riverPositions_mi = new Min(riverPositions_cu0, riverPositions_cu1);

	// 6: [Warped-rivers module]: This turbulence module warps the output value
	// from the combined-rivers module, which twists the rivers. The high
	// roughness produces less-smooth rivers.
	static private Double RIVER_POSITIONS_TU_FREQUENCY = 9.25;
	static private Double RIVER_POSITIONS_TU_SCALAR0 = 1.0;
	static private Double RIVER_POSITIONS_TU_SCALAR1 = 57.75;
	static private Integer RIVER_POSITIONS_TU_ROUGHNESS = 6;
	static private Turbulence riverPositions_tu = new Turbulence(riverPositions_mi);
	static {
		riverPositions_tu.setSeed(CUR_SEED + 102);
		riverPositions_tu.setFrequency(RIVER_POSITIONS_TU_FREQUENCY);
		riverPositions_tu.setPower(RIVER_POSITIONS_TU_SCALAR0 / RIVER_POSITIONS_TU_SCALAR1);
		riverPositions_tu.setRoughness(RIVER_POSITIONS_TU_ROUGHNESS);
	}

	// 7:
	static private Cached riverPositions = new Cached(riverPositions_tu);

	// //////////////////////////////////////////////////////////////////////////
	// Module group: scaled mountainous terrain
	// //////////////////////////////////////////////////////////////////////////

	// //////////////////////////////////////////////////////////////////////////
	// Module subgroup: scaled mountainous terrain (6 noise modules)
	//
	// This subgroup scales the output value from the mountainous-terrain group
	// so that it can be added to the elevation defined by the continent-
	// definition group.
	//
	// This subgroup scales the output value such that it is almost always
	// positive. This is done so that a negative elevation does not get applied
	// to the continent-definition group, preventing parts of that group from
	// having negative terrain features "stamped" into it.
	//
	// The output value from this module subgroup is measured in planetary
	// elevation units (-1.0 for the lowest underwater trenches and +1.0 for the
	// highest mountain peaks.)
	//

	// 1: [Base-scaled-mountainous-terrain module]: This scale/bias module
	// scales the output value from the mountainous-terrain group so that the
	// output value is measured in planetary elevation units.
	static private Double SCALED_MOUNTAINOUS_TERRAIN_SB0_SCALE = 0.125;
	static private Double SCALED_MOUNTAINOUS_TERRAIN_SB0_BIAS = 0.125;
	static private ScaleBias scaledMountainousTerrain_sb0 = new ScaleBias(mountainousTerrain);
	static {
		scaledMountainousTerrain_sb0.setScale(SCALED_MOUNTAINOUS_TERRAIN_SB0_SCALE);
		scaledMountainousTerrain_sb0.setBias(SCALED_MOUNTAINOUS_TERRAIN_SB0_BIAS);
	}

	// 2: [Base-peak-modulation module]: At this stage, most mountain peaks have
	// roughly the same elevation. This Perlin-noise module generates some
	// random values that will be used by subsequent noise modules to
	// randomly change the elevations of the mountain peaks.
	static private Double SCALED_MOUNTAINOUS_TERRAIN_PE_FREQUENCY = 14.5;
	static private Double SCALED_MOUNTAINOUS_TERRAIN_PE_PERSISTENCE = 0.5;
	static private Integer SCALED_MOUNTAINOUS_TERRAIN_PE_OCTAVE_COUNT = 6;
	static private Perlin scaledMountainousTerrain_pe = new Perlin();
	static {
		scaledMountainousTerrain_pe.setSeed(CUR_SEED + 110);
		scaledMountainousTerrain_pe.setFrequency(SCALED_MOUNTAINOUS_TERRAIN_PE_FREQUENCY);
		scaledMountainousTerrain_pe.setPersistence(SCALED_MOUNTAINOUS_TERRAIN_PE_PERSISTENCE);
		scaledMountainousTerrain_pe.setLacunarity(MOUNTAIN_LACUNARITY);
		scaledMountainousTerrain_pe.setOctaveCount(SCALED_MOUNTAINOUS_TERRAIN_PE_OCTAVE_COUNT);
		scaledMountainousTerrain_pe.setNoiseQuality(NoiseQuality.QUALITY_STD);
	}

	// 3: [Peak-modulation module]: This exponential-curve module applies an
	// exponential curve to the output value from the base-peak-modulation
	// module. This produces a small number of high values and a much larger
	// number of low values. This means there will be a few peaks with much
	// higher elevations than the majority of the peaks, making the terrain
	// features more varied.
	static private Double SCALED_MOUNTAINOUS_TERRAIN_EX_EXPONENT = 1.25;
	static private Exponent scaledMountainousTerrain_ex = new Exponent(scaledMountainousTerrain_pe);

	// 4: [Scaled-peak-modulation module]: This scale/bias module modifies the
	// range of the output value from the peak-modulation module so that it
	// can be used as the modulator for the peak-height-multiplier module.
	// It is important that this output value is not much lower than 1.0.
	static private Double SCALED_MOUNTAINOUS_TERRAIN_SB1_SCALE = 0.25;
	static private Double SCALED_MOUNTAINOUS_TERRAIN_SB1_BIAS = 1.0;
	static private ScaleBias scaledMountainousTerrain_sb1 = new ScaleBias(scaledMountainousTerrain_ex);
	static {
		scaledMountainousTerrain_sb0.setScale(SCALED_MOUNTAINOUS_TERRAIN_SB1_SCALE);
		scaledMountainousTerrain_sb0.setBias(SCALED_MOUNTAINOUS_TERRAIN_SB1_BIAS);
	}

	// 5: [Peak-height-multiplier module]: This multiplier module modulates the
	// heights of the mountain peaks from the base-scaled-mountainous-terrain
	// module using the output value from the scaled-peak-modulation module.
	static private Multiply scaledMountainousTerrain_mu = new Multiply(scaledMountainousTerrain_sb0,
			scaledMountainousTerrain_sb1);

	// 6:
	static private Cached scaledMountainousTerrain = new Cached(scaledMountainousTerrain_mu);

	// //////////////////////////////////////////////////////////////////////////
	// Module group: scaled hilly terrain
	// //////////////////////////////////////////////////////////////////////////

	// //////////////////////////////////////////////////////////////////////////
	// Module subgroup: scaled hilly terrain (6 noise modules)
	//
	// This subgroup scales the output value from the hilly-terrain group so
	// that it can be added to the elevation defined by the continent-
	// definition group. The scaling amount applied to the hills is one half of
	// the scaling amount applied to the scaled-mountainous-terrain group.
	//
	// This subgroup scales the output value such that it is almost always
	// positive. This is done so that negative elevations are not applied to
	// the continent-definition group, preventing parts of the continent-
	// definition group from having negative terrain features "stamped" into it.
	//
	// The output value from this module subgroup is measured in planetary
	// elevation units (-1.0 for the lowest underwater trenches and +1.0 for the
	// highest mountain peaks.)
	//

	// 1: [Base-scaled-hilly-terrain module]: This scale/bias module scales the
	// output value from the hilly-terrain group so that this output value is
	// measured in planetary elevation units
	static private Double SCALED_HILLY_TERRAIN_SB0_SCALE = 0.0625;
	static private Double SCALED_HILLY_TERRAIN_SB0_BIAS = 0.0625;
	static private ScaleBias scaledHillyTerrain_sb0 = new ScaleBias(hillyTerrain);
	static {
		scaledHillyTerrain_sb0.setScale(SCALED_HILLY_TERRAIN_SB0_SCALE);
		scaledHillyTerrain_sb0.setBias(SCALED_HILLY_TERRAIN_SB0_BIAS);
	}

	// 2: [Base-hilltop-modulation module]: At this stage, most hilltops have
	// roughly the same elevation. This Perlin-noise module generates some
	// random values that will be used by subsequent noise modules to
	// randomly change the elevations of the hilltops.
	static private Double SCALED_HILLY_TERRAIN_PE_FREQUENCY = 13.5;
	static private Double SCALED_HILLY_TERRAIN_PE_PERSISTENCE = 0.5;
	static private Integer SCALED_HILLY_TERRAIN_PE_OCTAVE_COUNT = 6;
	static private Perlin scaledHillyTerrain_pe = new Perlin();
	static {
		scaledHillyTerrain_pe.setSeed(CUR_SEED + 120);
		scaledHillyTerrain_pe.setFrequency(SCALED_HILLY_TERRAIN_PE_FREQUENCY);
		scaledHillyTerrain_pe.setPersistence(SCALED_HILLY_TERRAIN_PE_PERSISTENCE);
		scaledHillyTerrain_pe.setLacunarity(HILLS_LACUNARITY);
		scaledHillyTerrain_pe.setOctaveCount(SCALED_HILLY_TERRAIN_PE_OCTAVE_COUNT);
		scaledHillyTerrain_pe.setNoiseQuality(NoiseQuality.QUALITY_STD);
	}

	// 3: [Hilltop-modulation module]: This exponential-curve module applies an
	// exponential curve to the output value from the base-hilltop-modulation
	// module. This produces a small number of high values and a much larger
	// number of low values. This means there will be a few hilltops with
	// much higher elevations than the majority of the hilltops, making the
	// terrain features more varied.
	static private Double SCALED_HILLY_TERRAIN_EX_EXPONENT = 1.25;
	static private Exponent scaledHillyTerrain_ex = new Exponent(scaledHillyTerrain_pe);
	static {
		scaledHillyTerrain_ex.setExponent(SCALED_HILLY_TERRAIN_EX_EXPONENT);
	}

	// 4: [Scaled-hilltop-modulation module]: This scale/bias module modifies
	// the range of the output value from the hilltop-modulation module so
	// that it can be used as the modulator for the hilltop-height-multiplier
	// module. It is important that this output value is not much lower than
	// 1.0.
	static private Double SCALED_HILLY_TERRAIN_SB1_SCALE = 0.5;
	static private Double SCALED_HILLY_TERRAIN_SB1_BIAS = 1.5;
	static private ScaleBias scaledHillyTerrain_sb1 = new ScaleBias(hillyTerrain);
	static {
		scaledHillyTerrain_sb1.setScale(SCALED_HILLY_TERRAIN_SB1_SCALE);
		scaledHillyTerrain_sb1.setBias(SCALED_HILLY_TERRAIN_SB1_BIAS);
	}

	// 5: [Hilltop-height-multiplier module]: This multiplier module modulates
	// the heights of the hilltops from the base-scaled-hilly-terrain module
	// using the output value from the scaled-hilltop-modulation module.
	static private Multiply scaledHillyTerrain_mu = new Multiply(scaledHillyTerrain_sb0, scaledHillyTerrain_sb1);

	// 6:
	static private Cached scaledHillyTerrain = new Cached(scaledHillyTerrain_mu);

	// //////////////////////////////////////////////////////////////////////////
	// Module group: scaled plains terrain
	// //////////////////////////////////////////////////////////////////////////

	// //////////////////////////////////////////////////////////////////////////
	// Module subgroup: scaled plains terrain (2 noise modules)
	//
	// This subgroup scales the output value from the plains-terrain group so
	// that it can be added to the elevations defined by the continent-
	// definition group.
	//
	// This subgroup scales the output value such that it is almost always
	// positive. This is done so that negative elevations are not applied to
	// the continent-definition group, preventing parts of the continent-
	// definition group from having negative terrain features "stamped" into it.
	//
	// The output value from this module subgroup is measured in planetary
	// elevation units (-1.0 for the lowest underwater trenches and +1.0 for the
	// highest mountain peaks.)
	//

	// 1: [Scaled-plains-terrain module]: This scale/bias module greatly
	// flattens the output value from the plains terrain. This output value
	// is measured in planetary elevation units
	static private Double SCALED_PLAINS_TERRAIN_SB_SCALE = 0.00390625;
	static private Double SCALED_PLAINS_TERRAIN_SB_BIAS = 0.0078125;
	static private ScaleBias scaledPlainsTerrain_sb = new ScaleBias(plainsTerrain);
	static {
		scaledPlainsTerrain_sb.setScale(SCALED_PLAINS_TERRAIN_SB_SCALE);
		scaledPlainsTerrain_sb.setBias(SCALED_PLAINS_TERRAIN_SB_BIAS);
	}

	// 2:
	static private Cached scaledPlainsTerrain = new Cached(scaledPlainsTerrain_sb);

	// //////////////////////////////////////////////////////////////////////////
	// Module group: scaled badlands terrain
	// //////////////////////////////////////////////////////////////////////////

	// //////////////////////////////////////////////////////////////////////////
	// Module subgroup: scaled badlands terrain (2 noise modules)
	//
	// This subgroup scales the output value from the badlands-terrain group so
	// that it can be added to the elevations defined by the continent-
	// definition group.
	//
	// This subgroup scales the output value such that it is almost always
	// positive. This is done so that negative elevations are not applied to
	// the continent-definition group, preventing parts of the continent-
	// definition group from having negative terrain features "stamped" into it.
	//
	// The output value from this module subgroup is measured in planetary
	// elevation units (-1.0 for the lowest underwater trenches and +1.0 for the
	// highest mountain peaks.)
	//

	// 1: [Scaled-badlands-terrain module]: This scale/bias module scales the
	// output value from the badlands-terrain group so that it is measured
	// in planetary elevation units
	static private Double SCALED_BADLANDS_TERRAIN_SCALE = 0.0625;
	static private Double SCALED_BADLANDS_TERRAIN_BIAS = 0.0625;
	static private ScaleBias scaledBadlandsTerrain_sb = new ScaleBias(badlandsTerrain);
	static {
		scaledBadlandsTerrain_sb.setScale(SCALED_BADLANDS_TERRAIN_SCALE);
		scaledBadlandsTerrain_sb.setBias(SCALED_BADLANDS_TERRAIN_BIAS);
	}

	// 2:
	static private Cached scaledBadlandsTerrain = new Cached(scaledBadlandsTerrain_sb);

	// //////////////////////////////////////////////////////////////////////////
	// Module group: final planet
	// //////////////////////////////////////////////////////////////////////////

	// //////////////////////////////////////////////////////////////////////////
	// Module subgroup: continental shelf (6 noise modules)
	//
	// This module subgroup creates the continental shelves.
	//
	// The output value from this module subgroup are measured in planetary
	// elevation units (-1.0 for the lowest underwater trenches and +1.0 for the
	// highest mountain peaks.)
	//

	// 1: [Shelf-creator module]: This terracing module applies a terracing
	// curve to the continent-definition group at the specified shelf level.
	// This terrace becomes the continental shelf. Note that this terracing
	// module also places another terrace below the continental shelf near
	// -1.0. The bottom of this terrace is defined as the bottom of the
	// ocean; subsequent noise modules will later add oceanic trenches to the
	// bottom of the ocean.
	static private Double CONTINENTAL_SHELF_TE_LOWEST_CONTROL_POINT = -1.0;
	static private Double CONTINENTAL_SHELF_TE_LOW_CONTROL_POINT = -0.75;
	static private Double CONTINENTAL_SHELF_TE_HIGH_CONTROL_POINT = 1.0;
	static private Terrace continentalShelf_te = new Terrace(continentDef);
	static {
		continentalShelf_te.addControlPoint(CONTINENTAL_SHELF_TE_LOWEST_CONTROL_POINT);
		continentalShelf_te.addControlPoint(CONTINENTAL_SHELF_TE_LOW_CONTROL_POINT);
		continentalShelf_te.addControlPoint(SHELF_LEVEL);
		continentalShelf_te.addControlPoint(CONTINENTAL_SHELF_TE_HIGH_CONTROL_POINT);
	}

	// 2: [Oceanic-trench-basis module]: This ridged-multifractal-noise module
	// generates some coherent noise that will be used to generate the
	// oceanic trenches. The ridges represent the bottom of the trenches.
	static private Double CONTINENTAL_SHELF_FREQUENCY_SCALAR = 4.375;
	static private Integer CONTINENTAL_SHELF_FREQUENCY_OCTAVE_COUNT = 16;
	static private RidgedMulti continentalShelf_rm = new RidgedMulti();
	static {
		continentalShelf_rm.setSeed(CUR_SEED + 130);
		continentalShelf_rm.setFrequency(CONTINENT_FREQUENCY * CONTINENTAL_SHELF_FREQUENCY_SCALAR);
		continentalShelf_rm.setLacunarity(CONTINENT_LACUNARITY);
		continentalShelf_rm.setOctaveCount(CONTINENTAL_SHELF_FREQUENCY_OCTAVE_COUNT);
		continentalShelf_rm.setNoiseQuality(NoiseQuality.QUALITY_BEST);
	}

	// 3: [Oceanic-trench module]: This scale/bias module inverts the ridges
	// from the oceanic-trench-basis-module so that the ridges become
	// trenches. This noise module also reduces the depth of the trenches so
	// that their depths are measured in planetary elevation units.
	static private Double CONTINENTAL_SHELF_SB_SCALE = -0.125;
	static private Double CONTINENTAL_SHELF_SB_BIAS = -0.125;
	static private ScaleBias continentalShelf_sb = new ScaleBias(continentalShelf_rm);
	static {
		continentalShelf_sb.setScale(CONTINENTAL_SHELF_SB_SCALE);
		continentalShelf_sb.setBias(CONTINENTAL_SHELF_SB_BIAS);
	}

	// 4: [Clamped-sea-bottom module]: This clamping module clamps the output
	// value from the shelf-creator module so that its possible range is
	// from the bottom of the ocean to sea level. This is done because this
	// subgroup is only concerned about the oceans.
	static private Double CONTINENTAL_SHELF_CL_BOUNDS = -0.75;
	static private Clamp continentalShelf_cl = new Clamp(continentalShelf_te);
	static {
		continentalShelf_cl.setBounds(CONTINENTAL_SHELF_CL_BOUNDS, SEA_LEVEL);
	}

	// 5: [Shelf-and-trenches module]: This addition module adds the oceanic
	// trenches to the clamped-sea-bottom module.

	static private Add continentalShelf_ad = new Add(continentalShelf_sb, continentalShelf_cl);

	// 6:
	static private Cached continentalShelf = new Cached(continentalShelf_ad);

	// //////////////////////////////////////////////////////////////////////////
	// Module group: base continent elevations (3 noise modules)
	//
	// This subgroup generates the base elevations for the continents, before
	// terrain features are added.
	//
	// The output value from this module subgroup is measured in planetary
	// elevation units (-1.0 for the lowest underwater trenches and +1.0 for the
	// highest mountain peaks.)
	//

	// 1: [Base-scaled-continent-elevations module]: This scale/bias module
	// scales the output value from the continent-definition group so that it
	// is measured in planetary elevation units
	static private Double BASE_CONTINENT_ELEV_SB_BIAS = 0.0;
	static private ScaleBias baseContinentElev_sb = new ScaleBias(continentDef);
	static {
		baseContinentElev_sb.setScale(CONTINENT_HEIGHT_SCALE);
		baseContinentElev_sb.setBias(BASE_CONTINENT_ELEV_SB_BIAS);
	}

	// 2: [Base-continent-with-oceans module]: This selector module applies the
	// elevations of the continental shelves to the base elevations of the
	// continent. It does this by selecting the output value from the
	// continental-shelf subgroup if the corresponding output value from the
	// continent-definition group is below the shelf level. Otherwise, it
	// selects the output value from the base-scaled-continent-elevations
	// module.
	static private Double BASE_CONTINENT_ELEV_SE_BOUND_SCALAR = 1000.0;
	static private Double BASE_CONTINENT_ELEV_SE_EDGE_FALLOFF = 0.03125;
	static private Select baseContinentElev_se = new Select(baseContinentElev_sb, continentalShelf, continentDef);
	static {
		baseContinentElev_se.setBounds(SHELF_LEVEL - BASE_CONTINENT_ELEV_SE_BOUND_SCALAR, SHELF_LEVEL);
		baseContinentElev_se.setEdgeFalloff(BASE_CONTINENT_ELEV_SE_EDGE_FALLOFF);
	}

	// 3:
	static private Cached baseContinentElev = new Cached(baseContinentElev_se);

	// //////////////////////////////////////////////////////////////////////////
	// Module subgroup: continents with plains (2 noise modules)
	//
	// This subgroup applies the scaled-plains-terrain group to the base-
	// continent-elevation subgroup.
	//
	// The output value from this module subgroup is measured in planetary
	// elevation units (-1.0 for the lowest underwater trenches and +1.0 for the
	// highest mountain peaks.)
	//

	// 1: [Continents-with-plains module]: This addition module adds the
	// scaled-plains-terrain group to the base-continent-elevation subgroup.
	static private Add continentsWithPlains_ad = new Add(baseContinentElev, scaledPlainsTerrain);

	// 2:
	static private Cached continentsWithPlains = new Cached(continentsWithPlains_ad);

	// //////////////////////////////////////////////////////////////////////////
	// Module subgroup: continents with hills (3 noise modules)
	//
	// This subgroup applies the scaled-hilly-terrain group to the continents-
	// with-plains subgroup.
	//
	// The output value from this module subgroup is measured in planetary
	// elevation units (-1.0 for the lowest underwater trenches and +1.0 for the
	// highest mountain peaks.)
	//

	// 1: [Continents-with-hills module]: This addition module adds the scaled-
	// hilly-terrain group to the base-continent-elevation subgroup.
	static private Add continentsWithHills_ad = new Add(baseContinentElev, scaledHillyTerrain);

	// 2: [Select-high-elevations module]: This selector module ensures that
	// the hills only appear at higher elevations. It does this by selecting
	// the output value from the continent-with-hills module if the
	// corresponding output value from the terrain-type-defintion group is
	// above a certain value. Otherwise, it selects the output value from the
	// continents-with-plains subgroup.
	static private Double CONTINENTS_WITH_HILLS_BOUNDS_SCALAR0 = 1.0;
	static private Double CONTINENTS_WITH_HILLS_BOUNDS_SCALAR1 = 1001.0;
	static private Double CONTINENTS_WITH_HILLS_EDGE_FALLOFF = 0.25;
	static private Select continentsWithHills_se = new Select(continentsWithPlains, continentsWithHills_ad,
			terrainTypeDef);
	static {
		continentsWithHills_se.setBounds(CONTINENTS_WITH_HILLS_BOUNDS_SCALAR0 - HILLS_AMOUNT,
				CONTINENTS_WITH_HILLS_BOUNDS_SCALAR1 - HILLS_AMOUNT);
		continentsWithHills_se.setEdgeFalloff(CONTINENTS_WITH_HILLS_EDGE_FALLOFF);
	}

	// 3:
	static private Cached continentsWithHills = new Cached(continentsWithHills_se);

	// //////////////////////////////////////////////////////////////////////////
	// Module subgroup: continents with mountains (5 noise modules)
	//
	// This subgroup applies the scaled-mountainous-terrain group to the
	// continents-with-hills subgroup.
	//
	// The output value from this module subgroup is measured in planetary
	// elevation units (-1.0 for the lowest underwater trenches and +1.0 for the
	// highest mountain peaks.)
	//

	// 1: [Continents-and-mountains module]: This addition module adds the
	// scaled-mountainous-terrain group to the base-continent-elevation
	// subgroup.
	static private Add continentsWithMountains_ad0 = new Add(baseContinentElev, scaledMountainousTerrain);

	// 2: [Increase-mountain-heights module]: This curve module applies a curve
	// to the output value from the continent-definition group. This
	// modified output value is used by a subsequent noise module to add
	// additional height to the mountains based on the current continent
	// elevation. The higher the continent elevation, the higher the
	// mountains.
	static private Curve continentsWithMountains_cu = new Curve(continentDef);
	static {
		continentsWithMountains_cu.addControlPoint(-1.0, -0.0625);
		continentsWithMountains_cu.addControlPoint(0.0, 0.0000);
		continentsWithMountains_cu.addControlPoint(1.0 - MOUNTAINS_AMOUNT, 0.0625);
		continentsWithMountains_cu.addControlPoint(1.0, 0.2500);
	}

	// 3: [Add-increased-mountain-heights module]: This addition module adds
	// the increased-mountain-heights module to the continents-and-
	// mountains module. The highest continent elevations now have the
	// highest mountains.
	static private Add continentsWithMountains_ad1 = new Add(continentsWithMountains_ad0, continentsWithMountains_cu);

	// 4: [Select-high-elevations module]: This selector module ensures that
	// mountains only appear at higher elevations. It does this by selecting
	// the output value from the continent-with-mountains module if the
	// corresponding output value from the terrain-type-defintion group is
	// above a certain value. Otherwise, it selects the output value from
	// the continents-with-hills subgroup. Note that the continents-with-
	// hills subgroup also contains the plains terrain.
	static private Double CONTINENT_WITH_MOUNTAINS_BOUNDS_SCALAR0 = 1.0;
	static private Double CONTINENT_WITH_MOUNTAINS_BOUNDS_SCALAR1 = 1001.0;
	static private Double CONTINENT_WITH_MOUNTAINS_EDGE_FALLOFF = 0.25;
	static private Select continentsWithMountains_se = new Select(continentsWithHills, continentsWithMountains_ad1,
			terrainTypeDef);
	static {
		continentsWithMountains_se.setBounds(CONTINENT_WITH_MOUNTAINS_BOUNDS_SCALAR0 - MOUNTAINS_AMOUNT,
				CONTINENT_WITH_MOUNTAINS_BOUNDS_SCALAR1 - MOUNTAINS_AMOUNT);
		continentsWithMountains_se.setEdgeFalloff(CONTINENT_WITH_MOUNTAINS_EDGE_FALLOFF);
	}

	// 5:
	static private Cached continentsWithMountains = new Cached(continentsWithMountains_se);

	// //////////////////////////////////////////////////////////////////////////
	// Module subgroup: continents with badlands (5 noise modules)
	//
	// This subgroup applies the scaled-badlands-terrain group to the
	// continents-with-mountains subgroup.
	//
	// The output value from this module subgroup is measured in planetary
	// elevation units (-1.0 for the lowest underwater trenches and +1.0 for the
	// highest mountain peaks.)
	//

	// 1: [Badlands-positions module]: This Perlin-noise module generates some
	// random noise, which is used by subsequent noise modules to specify the
	// locations of the badlands.
	static private Double CONTINENTS_WITH_BADLANDS_PE_FREQUENCY = 16.5;
	static private Double CONTINENTS_WITH_BADLANDS_PE_PERSISTENCE = 0.5;
	static private Integer CONTINENTS_WITH_BADLANDS_PE_OCTAVE_COUNT = 2;
	static private Perlin continentsWithBadlands_pe = new Perlin();
	static {
		continentsWithBadlands_pe.setSeed(CUR_SEED + 140);
		continentsWithBadlands_pe.setFrequency(CONTINENTS_WITH_BADLANDS_PE_FREQUENCY);
		continentsWithBadlands_pe.setPersistence(CONTINENTS_WITH_BADLANDS_PE_PERSISTENCE);
		continentsWithBadlands_pe.setLacunarity(CONTINENT_LACUNARITY);
		continentsWithBadlands_pe.setOctaveCount(CONTINENTS_WITH_BADLANDS_PE_OCTAVE_COUNT);
		continentsWithBadlands_pe.setNoiseQuality(NoiseQuality.QUALITY_STD);
	}

	// 2: [Continents-and-badlands module]: This addition module adds the
	// scaled-badlands-terrain group to the base-continent-elevation
	// subgroup.
	static private Add continentsWithBadlands_ad = new Add(baseContinentElev, scaledBadlandsTerrain);

	// 3: [Select-badlands-positions module]: This selector module places
	// badlands at random spots on the continents based on the Perlin noise
	// generated by the badlands-positions module. To do this, it selects
	// the output value from the continents-and-badlands module if the
	// corresponding output value from the badlands-position module is
	// greater than a specified value. Otherwise, this selector module
	// selects the output value from the continents-with-mountains subgroup.
	// There is also a wide transition between these two noise modules so
	// that the badlands can blend into the rest of the terrain on the
	// continents.
	static private Double CONTINENTS_WITH_BADLANDS_SE_BOUNDS_PARAM0 = 1.0;
	static private Double CONTINENTS_WITH_BADLANDS_SE_BOUNDS_PARAM1 = 1001.0;
	static private Double CONTINENTS_WITH_BADLANDS_SE_EDGE_FALLOFF = 0.25;
	static private Select continentsWithBadlands_se = new Select(continentsWithMountains, continentsWithBadlands_ad,
			continentsWithBadlands_pe);
	static {
		continentsWithBadlands_se.setBounds(CONTINENTS_WITH_BADLANDS_SE_BOUNDS_PARAM0 - BADLANDS_AMOUNT,
				CONTINENTS_WITH_BADLANDS_SE_BOUNDS_PARAM1 - BADLANDS_AMOUNT);
		continentsWithBadlands_se.setEdgeFalloff(CONTINENTS_WITH_BADLANDS_SE_EDGE_FALLOFF);
	}

	// 4: [Apply-badlands module]: This maximum-value module causes the badlands
	// to "poke out" from the rest of the terrain. It does this by ensuring
	// that only the maximum of the output values from the continents-with-
	// mountains subgroup and the select-badlands-positions modules
	// contribute to the output value of this subgroup. One side effect of
	// this process is that the badlands will not appear in mountainous
	// terrain.

	static private Max continentsWithBadlands_ma = new Max(continentsWithMountains, continentsWithBadlands_se);

	// 5:
	static private Cached continentsWithBadlands = new Cached(continentsWithBadlands_ma);

	// //////////////////////////////////////////////////////////////////////////
	// Module subgroup: continents with rivers (4 noise modules)
	//
	// This subgroup applies the river-positions group to the continents-with-
	// badlands subgroup.
	//
	// The output value from this module subgroup is measured in planetary
	// elevation units (-1.0 for the lowest underwater trenches and +1.0 for the
	// highest mountain peaks.)
	//

	// 1: [Scaled-rivers module]: This scale/bias module scales the output value
	// from the river-positions group so that it is measured in planetary
	// elevation units and is negative; this is required for step 2.
	static private Double CONTINENTS_WITH_RIVERS_SB_SCALAR0 = 2.0;
	static private Double CONTINENTS_WITH_RIVERS_SB_SCALAR1 = 2.0;
	static private ScaleBias continentsWithRivers_sb = new ScaleBias(riverPositions);
	static {
		continentsWithRivers_sb.setScale(RIVER_DEPTH / CONTINENTS_WITH_RIVERS_SB_SCALAR0);
		continentsWithRivers_sb.setBias(RIVER_DEPTH / CONTINENTS_WITH_RIVERS_SB_SCALAR1);
	}

	// 2: [Add-rivers-to-continents module]: This addition module adds the
	// rivers to the continents-with-badlands subgroup. Because the scaled-
	// rivers module only outputs a negative value, the scaled-rivers module
	// carves the rivers out of the terrain.
	static private Add continentsWithRivers_ad = new Add(continentsWithBadlands, continentsWithRivers_sb);
	// 3: [Blended-rivers-to-continents module]: This selector module outputs
	// deep rivers near sea level and shallower rivers in higher terrain. It
	// does this by selecting the output value from the continents-with-
	// badlands subgroup if the corresponding output value from the
	// continents-with-badlands subgroup is far from sea level. Otherwise,
	// this selector module selects the output value from the add-rivers-to-
	// continents module.
	static private Select continentsWithRivers_se = new Select(continentsWithBadlands, continentsWithRivers_ad,
			continentsWithBadlands);
	static {
		continentsWithRivers_se.setBounds(SEA_LEVEL, CONTINENT_HEIGHT_SCALE - SEA_LEVEL);
	}
	// 4:
	static private Cached continentsWithRivers = new Cached(continentsWithRivers_se);
	// 1:
	static private Cached unscaledPlanet = new Cached(continentsWithRivers);

	// //////////////////////////////////////////////////////////////////////////
	// Module subgroup: final planet (2 noise modules)
	//
	// This subgroup scales the output value from the unscaled-final-planet
	// subgroup so that it represents an elevation in meters.
	//

	// 1: [Final-planet-in-meters module]: This scale/bias module scales the
	// output value from the unscaled-final-planet subgroup so that its
	// output value is measured in meters.
	static private ScaleBias finalPlanet_sb = new ScaleBias(unscaledPlanet);
	static {
		finalPlanet_sb.setScale((MAX_ELEV - MIN_ELEV) / 2.0);
		finalPlanet_sb.setBias(MIN_ELEV + ((MAX_ELEV - MIN_ELEV) / 2.0));
	}
	static private ScaleBias finalPlanet_sb2 = new ScaleBias(unscaledPlanet);
	static {
		finalPlanet_sb.setScale((MAX_ELEV - MIN_ELEV) / 3.0);
		finalPlanet_sb.setBias(MIN_ELEV + ((MAX_ELEV - MIN_ELEV) / 3.0));
	}
	// 2:
	static private Cached finalPlanet = new Cached(finalPlanet_sb);
	static private Cached finalPlanet2 = new Cached(finalPlanet_sb2);

	/**
	 * t e s t s s t a r t h e r e
	 */

	public static void complexPlanetTest() {
		NoiseMapBuilderSphere planet = new NoiseMapBuilderSphere();
		NoiseMap elevGrid = new NoiseMap(GRID_WIDTH, GRID_HEIGHT);

		planet.setBounds(SOUTH_COORD, NORTH_COORD, WEST_COORD, EAST_COORD);
		planet.setDestSize(GRID_WIDTH, GRID_HEIGHT);

		planet.setSourceModule(finalPlanet_sb);
		planet.setDestNoiseMap(elevGrid);
		planet.build();
		RenderImageSphereParameter renderImageParameter = new RenderImageSphereParameter(gradientPointList, elevGrid,
				Boolean.TRUE, lightContrast, lightBrightness, lightElevation, lightAzumith);
		ImageCafe imageCafe = Builder.buildRendererImage(renderImageParameter);
		String uri = "images/" + Math.random() + "complextPlanetCompleteRand_test.png";
		Output.writer(imageCafe, uri);

	}

	public static void complexPlanetTest2() {
		NoiseMapBuilderSphere planet = new NoiseMapBuilderSphere();
		NoiseMap elevGrid = new NoiseMap(GRID_WIDTH, GRID_HEIGHT);

		planet.setBounds(SOUTH_COORD, NORTH_COORD, WEST_COORD, EAST_COORD);
		planet.setDestSize(GRID_WIDTH, GRID_HEIGHT);

		planet.setSourceModule(finalPlanet_sb2);
		planet.setDestNoiseMap(elevGrid);
		planet.build();
		RenderImageParameter renderImageParameter = new RenderImageParameter(gradientPointList2, elevGrid,
				Boolean.FALSE, lightContrast, lightBrightness);
		ImageCafe imageCafe = Builder.buildRendererImage(renderImageParameter);
		String uri = "images/" + Math.random() + "complextPlanetCompleteRand_test2.png";
		Output.writer(imageCafe, uri);

	}

	public static void main(String[] args) {
		complexPlanetTest();
		complexPlanetTest2();
	}

}
